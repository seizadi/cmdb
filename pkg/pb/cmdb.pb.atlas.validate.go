// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/seizadi/cmdb/pkg/pb/cmdb.proto

package pb // import "github.com/seizadi/cmdb/pkg/pb"

import bytes "bytes"
import context "context"
import fmt "fmt"
import http "net/http"
import ioutil "io/ioutil"
import json "encoding/json"
import metadata "google.golang.org/grpc/metadata"
import runtime "github.com/grpc-ecosystem/grpc-gateway/runtime"
import runtime1 "github.com/infobloxopen/protoc-gen-atlas-validate/runtime"
import resource "github.com/infobloxopen/atlas-app-toolkit/rpc/resource"
import query "github.com/infobloxopen/atlas-app-toolkit/query"
import field_mask "google.golang.org/genproto/protobuf/field_mask"
import types "github.com/infobloxopen/protoc-gen-gorm/types"
import proto "github.com/gogo/protobuf/proto"
import math "math"
import _ "github.com/golang/protobuf/ptypes/empty"
import _ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
import _ "github.com/infobloxopen/atlas-app-toolkit/query"
import _ "github.com/infobloxopen/atlas-app-toolkit/rpc/resource"
import _ "github.com/infobloxopen/protoc-gen-atlas-query-validate/options"
import _ "github.com/infobloxopen/protoc-gen-atlas-validate/options"
import _ "github.com/infobloxopen/protoc-gen-gorm/options"
import _ "github.com/infobloxopen/protoc-gen-gorm/types"
import _ "github.com/lyft/protoc-gen-validate/validate"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "google.golang.org/genproto/protobuf/field_mask"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// validate_Cmdb_GetVersion_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Cmdb_GetVersion_0.
func validate_Cmdb_GetVersion_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_CloudProviders_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_CloudProviders_Create_0.
func validate_CloudProviders_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_CloudProvider(ctx, r, "")
}

// validate_CloudProviders_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_CloudProviders_Read_0.
func validate_CloudProviders_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_CloudProviders_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_CloudProviders_Update_0.
func validate_CloudProviders_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_CloudProvider(ctx, r, "")
}

// validate_CloudProviders_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_CloudProviders_Update_1.
func validate_CloudProviders_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_CloudProvider(ctx, r, "")
}

// validate_CloudProviders_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_CloudProviders_Delete_0.
func validate_CloudProviders_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_CloudProviders_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_CloudProviders_List_0.
func validate_CloudProviders_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Regions_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_Regions_Create_0.
func validate_Regions_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Region(ctx, r, "")
}

// validate_Regions_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Regions_Read_0.
func validate_Regions_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Regions_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_Regions_Update_0.
func validate_Regions_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Region(ctx, r, "")
}

// validate_Regions_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_Regions_Update_1.
func validate_Regions_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Region(ctx, r, "")
}

// validate_Regions_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_Regions_Delete_0.
func validate_Regions_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Regions_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Regions_List_0.
func validate_Regions_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Networks_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_Networks_Create_0.
func validate_Networks_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Network(ctx, r, "")
}

// validate_Networks_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Networks_Read_0.
func validate_Networks_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Networks_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_Networks_Update_0.
func validate_Networks_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Network(ctx, r, "")
}

// validate_Networks_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_Networks_Update_1.
func validate_Networks_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Network(ctx, r, "")
}

// validate_Networks_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_Networks_Delete_0.
func validate_Networks_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Networks_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Networks_List_0.
func validate_Networks_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Lifecycles_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_Lifecycles_Create_0.
func validate_Lifecycles_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Lifecycle(ctx, r, "")
}

// validate_Lifecycles_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Lifecycles_Read_0.
func validate_Lifecycles_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Lifecycles_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_Lifecycles_Update_0.
func validate_Lifecycles_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Lifecycle(ctx, r, "")
}

// validate_Lifecycles_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_Lifecycles_Update_1.
func validate_Lifecycles_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Lifecycle(ctx, r, "")
}

// validate_Lifecycles_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_Lifecycles_Delete_0.
func validate_Lifecycles_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Lifecycles_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Lifecycles_List_0.
func validate_Lifecycles_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_ChartVersions_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_ChartVersions_Create_0.
func validate_ChartVersions_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_ChartVersion(ctx, r, "")
}

// validate_ChartVersions_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_ChartVersions_Read_0.
func validate_ChartVersions_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_ChartVersions_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_ChartVersions_Update_0.
func validate_ChartVersions_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_ChartVersion(ctx, r, "")
}

// validate_ChartVersions_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_ChartVersions_Update_1.
func validate_ChartVersions_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_ChartVersion(ctx, r, "")
}

// validate_ChartVersions_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_ChartVersions_Delete_0.
func validate_ChartVersions_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_ChartVersions_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_ChartVersions_List_0.
func validate_ChartVersions_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_AppConfigs_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_AppConfigs_Create_0.
func validate_AppConfigs_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_AppConfig(ctx, r, "")
}

// validate_AppConfigs_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_AppConfigs_Read_0.
func validate_AppConfigs_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_AppConfigs_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_AppConfigs_Update_0.
func validate_AppConfigs_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_AppConfig(ctx, r, "")
}

// validate_AppConfigs_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_AppConfigs_Update_1.
func validate_AppConfigs_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_AppConfig(ctx, r, "")
}

// validate_AppConfigs_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_AppConfigs_Delete_0.
func validate_AppConfigs_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_AppConfigs_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_AppConfigs_List_0.
func validate_AppConfigs_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Environments_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_Environments_Create_0.
func validate_Environments_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Environment(ctx, r, "")
}

// validate_Environments_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Environments_Read_0.
func validate_Environments_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Environments_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_Environments_Update_0.
func validate_Environments_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Environment(ctx, r, "")
}

// validate_Environments_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_Environments_Update_1.
func validate_Environments_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Environment(ctx, r, "")
}

// validate_Environments_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_Environments_Delete_0.
func validate_Environments_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Environments_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Environments_List_0.
func validate_Environments_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Applications_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_Applications_Create_0.
func validate_Applications_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Application(ctx, r, "")
}

// validate_Applications_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Applications_Read_0.
func validate_Applications_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Applications_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_Applications_Update_0.
func validate_Applications_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Application(ctx, r, "")
}

// validate_Applications_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_Applications_Update_1.
func validate_Applications_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Application(ctx, r, "")
}

// validate_Applications_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_Applications_Delete_0.
func validate_Applications_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Applications_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Applications_List_0.
func validate_Applications_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_AppVersions_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_AppVersions_Create_0.
func validate_AppVersions_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_AppVersion(ctx, r, "")
}

// validate_AppVersions_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_AppVersions_Read_0.
func validate_AppVersions_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_AppVersions_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_AppVersions_Update_0.
func validate_AppVersions_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_AppVersion(ctx, r, "")
}

// validate_AppVersions_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_AppVersions_Update_1.
func validate_AppVersions_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_AppVersion(ctx, r, "")
}

// validate_AppVersions_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_AppVersions_Delete_0.
func validate_AppVersions_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_AppVersions_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_AppVersions_List_0.
func validate_AppVersions_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_ApplicationInstances_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_ApplicationInstances_Create_0.
func validate_ApplicationInstances_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_ApplicationInstance(ctx, r, "")
}

// validate_ApplicationInstances_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_ApplicationInstances_Read_0.
func validate_ApplicationInstances_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_ApplicationInstances_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_ApplicationInstances_Update_0.
func validate_ApplicationInstances_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_ApplicationInstance(ctx, r, "")
}

// validate_ApplicationInstances_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_ApplicationInstances_Update_1.
func validate_ApplicationInstances_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_ApplicationInstance(ctx, r, "")
}

// validate_ApplicationInstances_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_ApplicationInstances_Delete_0.
func validate_ApplicationInstances_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_ApplicationInstances_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_ApplicationInstances_List_0.
func validate_ApplicationInstances_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Vaults_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_Vaults_Create_0.
func validate_Vaults_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Vault(ctx, r, "")
}

// validate_Vaults_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Vaults_Read_0.
func validate_Vaults_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Vaults_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_Vaults_Update_0.
func validate_Vaults_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Vault(ctx, r, "")
}

// validate_Vaults_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_Vaults_Update_1.
func validate_Vaults_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Vault(ctx, r, "")
}

// validate_Vaults_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_Vaults_Delete_0.
func validate_Vaults_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Vaults_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Vaults_List_0.
func validate_Vaults_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Secrets_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_Secrets_Create_0.
func validate_Secrets_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Secret(ctx, r, "")
}

// validate_Secrets_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Secrets_Read_0.
func validate_Secrets_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Secrets_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_Secrets_Update_0.
func validate_Secrets_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Secret(ctx, r, "")
}

// validate_Secrets_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_Secrets_Update_1.
func validate_Secrets_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Secret(ctx, r, "")
}

// validate_Secrets_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_Secrets_Delete_0.
func validate_Secrets_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Secrets_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Secrets_List_0.
func validate_Secrets_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Artifacts_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_Artifacts_Create_0.
func validate_Artifacts_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Artifact(ctx, r, "")
}

// validate_Artifacts_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Artifacts_Read_0.
func validate_Artifacts_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Artifacts_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_Artifacts_Update_0.
func validate_Artifacts_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Artifact(ctx, r, "")
}

// validate_Artifacts_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_Artifacts_Update_1.
func validate_Artifacts_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Artifact(ctx, r, "")
}

// validate_Artifacts_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_Artifacts_Delete_0.
func validate_Artifacts_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Artifacts_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Artifacts_List_0.
func validate_Artifacts_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_KubeClusters_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_KubeClusters_Create_0.
func validate_KubeClusters_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_KubeCluster(ctx, r, "")
}

// validate_KubeClusters_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_KubeClusters_Read_0.
func validate_KubeClusters_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_KubeClusters_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_KubeClusters_Update_0.
func validate_KubeClusters_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_KubeCluster(ctx, r, "")
}

// validate_KubeClusters_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_KubeClusters_Update_1.
func validate_KubeClusters_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_KubeCluster(ctx, r, "")
}

// validate_KubeClusters_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_KubeClusters_Delete_0.
func validate_KubeClusters_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_KubeClusters_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_KubeClusters_List_0.
func validate_KubeClusters_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Deployments_Create_0 is an entrypoint for validating "POST" HTTP request
// that match *.pb.gw.go/pattern_Deployments_Create_0.
func validate_Deployments_Create_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Deployment(ctx, r, "")
}

// validate_Deployments_Read_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Deployments_Read_0.
func validate_Deployments_Read_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Deployments_Update_0 is an entrypoint for validating "PUT" HTTP request
// that match *.pb.gw.go/pattern_Deployments_Update_0.
func validate_Deployments_Update_0(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Deployment(ctx, r, "")
}

// validate_Deployments_Update_1 is an entrypoint for validating "PATCH" HTTP request
// that match *.pb.gw.go/pattern_Deployments_Update_1.
func validate_Deployments_Update_1(ctx context.Context, r json.RawMessage) (err error) {
	return validate_Object_Deployment(ctx, r, "")
}

// validate_Deployments_Delete_0 is an entrypoint for validating "DELETE" HTTP request
// that match *.pb.gw.go/pattern_Deployments_Delete_0.
func validate_Deployments_Delete_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Deployments_List_0 is an entrypoint for validating "GET" HTTP request
// that match *.pb.gw.go/pattern_Deployments_List_0.
func validate_Deployments_List_0(ctx context.Context, r json.RawMessage) (err error) {
	if len(r) != 0 {
		return fmt.Errorf("body is not allowed")
	}
	return nil
}

// validate_Object_VersionResponse function validates a JSON for a given object.
func validate_Object_VersionResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&VersionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_VersionResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "version":
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object VersionResponse.
func (_ *VersionResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&VersionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_VersionResponse(ctx, r, path)
}

func validate_required_Object_VersionResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CloudProvider function validates a JSON for a given object.
func validate_Object_CloudProvider(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CloudProvider{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CloudProvider(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "provider":
		case "account":
		case "regions":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Region(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CloudProvider.
func (_ *CloudProvider) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CloudProvider{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CloudProvider(ctx, r, path)
}

func validate_required_Object_CloudProvider(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateCloudProviderRequest function validates a JSON for a given object.
func validate_Object_CreateCloudProviderRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateCloudProviderRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateCloudProviderRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_CloudProvider(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateCloudProviderRequest.
func (_ *CreateCloudProviderRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateCloudProviderRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateCloudProviderRequest(ctx, r, path)
}

func validate_required_Object_CreateCloudProviderRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateCloudProviderResponse function validates a JSON for a given object.
func validate_Object_CreateCloudProviderResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateCloudProviderResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateCloudProviderResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_CloudProvider(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateCloudProviderResponse.
func (_ *CreateCloudProviderResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateCloudProviderResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateCloudProviderResponse(ctx, r, path)
}

func validate_required_Object_CreateCloudProviderResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadCloudProviderRequest function validates a JSON for a given object.
func validate_Object_ReadCloudProviderRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadCloudProviderRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadCloudProviderRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadCloudProviderRequest.
func (_ *ReadCloudProviderRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadCloudProviderRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadCloudProviderRequest(ctx, r, path)
}

func validate_required_Object_ReadCloudProviderRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadCloudProviderResponse function validates a JSON for a given object.
func validate_Object_ReadCloudProviderResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadCloudProviderResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadCloudProviderResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_CloudProvider(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadCloudProviderResponse.
func (_ *ReadCloudProviderResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadCloudProviderResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadCloudProviderResponse(ctx, r, path)
}

func validate_required_Object_ReadCloudProviderResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateCloudProviderRequest function validates a JSON for a given object.
func validate_Object_UpdateCloudProviderRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateCloudProviderRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateCloudProviderRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_CloudProvider(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateCloudProviderRequest.
func (_ *UpdateCloudProviderRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateCloudProviderRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateCloudProviderRequest(ctx, r, path)
}

func validate_required_Object_UpdateCloudProviderRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateCloudProviderResponse function validates a JSON for a given object.
func validate_Object_UpdateCloudProviderResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateCloudProviderResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateCloudProviderResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_CloudProvider(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateCloudProviderResponse.
func (_ *UpdateCloudProviderResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateCloudProviderResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateCloudProviderResponse(ctx, r, path)
}

func validate_required_Object_UpdateCloudProviderResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteCloudProviderRequest function validates a JSON for a given object.
func validate_Object_DeleteCloudProviderRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteCloudProviderRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteCloudProviderRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteCloudProviderRequest.
func (_ *DeleteCloudProviderRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteCloudProviderRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteCloudProviderRequest(ctx, r, path)
}

func validate_required_Object_DeleteCloudProviderRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteCloudProviderResponse function validates a JSON for a given object.
func validate_Object_DeleteCloudProviderResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteCloudProviderResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteCloudProviderResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteCloudProviderResponse.
func (_ *DeleteCloudProviderResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteCloudProviderResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteCloudProviderResponse(ctx, r, path)
}

func validate_required_Object_DeleteCloudProviderResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListCloudProviderRequest function validates a JSON for a given object.
func validate_Object_ListCloudProviderRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListCloudProviderRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListCloudProviderRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListCloudProviderRequest.
func (_ *ListCloudProviderRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListCloudProviderRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListCloudProviderRequest(ctx, r, path)
}

func validate_required_Object_ListCloudProviderRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListCloudProvidersResponse function validates a JSON for a given object.
func validate_Object_ListCloudProvidersResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListCloudProvidersResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListCloudProvidersResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_CloudProvider(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListCloudProvidersResponse.
func (_ *ListCloudProvidersResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListCloudProvidersResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListCloudProvidersResponse(ctx, r, path)
}

func validate_required_Object_ListCloudProvidersResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_Region function validates a JSON for a given object.
func validate_Object_Region(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Region{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_Region(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "networks":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Network(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "cloud_provider_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object Region.
func (_ *Region) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Region{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_Region(ctx, r, path)
}

func validate_required_Object_Region(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateRegionRequest function validates a JSON for a given object.
func validate_Object_CreateRegionRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateRegionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateRegionRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Region(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateRegionRequest.
func (_ *CreateRegionRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateRegionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateRegionRequest(ctx, r, path)
}

func validate_required_Object_CreateRegionRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateRegionResponse function validates a JSON for a given object.
func validate_Object_CreateRegionResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateRegionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateRegionResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Region(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateRegionResponse.
func (_ *CreateRegionResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateRegionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateRegionResponse(ctx, r, path)
}

func validate_required_Object_CreateRegionResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadRegionRequest function validates a JSON for a given object.
func validate_Object_ReadRegionRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadRegionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadRegionRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadRegionRequest.
func (_ *ReadRegionRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadRegionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadRegionRequest(ctx, r, path)
}

func validate_required_Object_ReadRegionRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadRegionResponse function validates a JSON for a given object.
func validate_Object_ReadRegionResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadRegionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadRegionResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Region(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadRegionResponse.
func (_ *ReadRegionResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadRegionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadRegionResponse(ctx, r, path)
}

func validate_required_Object_ReadRegionResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateRegionRequest function validates a JSON for a given object.
func validate_Object_UpdateRegionRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateRegionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateRegionRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Region(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateRegionRequest.
func (_ *UpdateRegionRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateRegionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateRegionRequest(ctx, r, path)
}

func validate_required_Object_UpdateRegionRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateRegionResponse function validates a JSON for a given object.
func validate_Object_UpdateRegionResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateRegionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateRegionResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Region(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateRegionResponse.
func (_ *UpdateRegionResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateRegionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateRegionResponse(ctx, r, path)
}

func validate_required_Object_UpdateRegionResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteRegionRequest function validates a JSON for a given object.
func validate_Object_DeleteRegionRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteRegionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteRegionRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteRegionRequest.
func (_ *DeleteRegionRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteRegionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteRegionRequest(ctx, r, path)
}

func validate_required_Object_DeleteRegionRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteRegionResponse function validates a JSON for a given object.
func validate_Object_DeleteRegionResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteRegionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteRegionResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteRegionResponse.
func (_ *DeleteRegionResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteRegionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteRegionResponse(ctx, r, path)
}

func validate_required_Object_DeleteRegionResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListRegionRequest function validates a JSON for a given object.
func validate_Object_ListRegionRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListRegionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListRegionRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListRegionRequest.
func (_ *ListRegionRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListRegionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListRegionRequest(ctx, r, path)
}

func validate_required_Object_ListRegionRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListRegionsResponse function validates a JSON for a given object.
func validate_Object_ListRegionsResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListRegionsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListRegionsResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Region(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListRegionsResponse.
func (_ *ListRegionsResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListRegionsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListRegionsResponse(ctx, r, path)
}

func validate_required_Object_ListRegionsResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_Network function validates a JSON for a given object.
func validate_Object_Network(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Network{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_Network(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "region_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object Network.
func (_ *Network) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Network{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_Network(ctx, r, path)
}

func validate_required_Object_Network(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateNetworkRequest function validates a JSON for a given object.
func validate_Object_CreateNetworkRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateNetworkRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateNetworkRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Network(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateNetworkRequest.
func (_ *CreateNetworkRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateNetworkRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateNetworkRequest(ctx, r, path)
}

func validate_required_Object_CreateNetworkRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateNetworkResponse function validates a JSON for a given object.
func validate_Object_CreateNetworkResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateNetworkResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateNetworkResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Network(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateNetworkResponse.
func (_ *CreateNetworkResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateNetworkResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateNetworkResponse(ctx, r, path)
}

func validate_required_Object_CreateNetworkResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadNetworkRequest function validates a JSON for a given object.
func validate_Object_ReadNetworkRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadNetworkRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadNetworkRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadNetworkRequest.
func (_ *ReadNetworkRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadNetworkRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadNetworkRequest(ctx, r, path)
}

func validate_required_Object_ReadNetworkRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadNetworkResponse function validates a JSON for a given object.
func validate_Object_ReadNetworkResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadNetworkResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadNetworkResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Network(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadNetworkResponse.
func (_ *ReadNetworkResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadNetworkResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadNetworkResponse(ctx, r, path)
}

func validate_required_Object_ReadNetworkResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateNetworkRequest function validates a JSON for a given object.
func validate_Object_UpdateNetworkRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateNetworkRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateNetworkRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Network(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateNetworkRequest.
func (_ *UpdateNetworkRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateNetworkRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateNetworkRequest(ctx, r, path)
}

func validate_required_Object_UpdateNetworkRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateNetworkResponse function validates a JSON for a given object.
func validate_Object_UpdateNetworkResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateNetworkResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateNetworkResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Network(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateNetworkResponse.
func (_ *UpdateNetworkResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateNetworkResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateNetworkResponse(ctx, r, path)
}

func validate_required_Object_UpdateNetworkResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteNetworkRequest function validates a JSON for a given object.
func validate_Object_DeleteNetworkRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteNetworkRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteNetworkRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteNetworkRequest.
func (_ *DeleteNetworkRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteNetworkRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteNetworkRequest(ctx, r, path)
}

func validate_required_Object_DeleteNetworkRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteNetworkResponse function validates a JSON for a given object.
func validate_Object_DeleteNetworkResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteNetworkResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteNetworkResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteNetworkResponse.
func (_ *DeleteNetworkResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteNetworkResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteNetworkResponse(ctx, r, path)
}

func validate_required_Object_DeleteNetworkResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListNetworkRequest function validates a JSON for a given object.
func validate_Object_ListNetworkRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListNetworkRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListNetworkRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListNetworkRequest.
func (_ *ListNetworkRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListNetworkRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListNetworkRequest(ctx, r, path)
}

func validate_required_Object_ListNetworkRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListNetworksResponse function validates a JSON for a given object.
func validate_Object_ListNetworksResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListNetworksResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListNetworksResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Network(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListNetworksResponse.
func (_ *ListNetworksResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListNetworksResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListNetworksResponse(ctx, r, path)
}

func validate_required_Object_ListNetworksResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_Lifecycle function validates a JSON for a given object.
func validate_Object_Lifecycle(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Lifecycle{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_Lifecycle(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "config_yaml":
		case "environments":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Environment(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "lifecycles":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Lifecycle(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "app_config":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_AppConfig(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "app_version":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_AppVersion(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "lifecycle_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object Lifecycle.
func (_ *Lifecycle) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Lifecycle{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_Lifecycle(ctx, r, path)
}

func validate_required_Object_Lifecycle(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateLifecycleRequest function validates a JSON for a given object.
func validate_Object_CreateLifecycleRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateLifecycleRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateLifecycleRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Lifecycle(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateLifecycleRequest.
func (_ *CreateLifecycleRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateLifecycleRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateLifecycleRequest(ctx, r, path)
}

func validate_required_Object_CreateLifecycleRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateLifecycleResponse function validates a JSON for a given object.
func validate_Object_CreateLifecycleResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateLifecycleResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateLifecycleResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Lifecycle(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateLifecycleResponse.
func (_ *CreateLifecycleResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateLifecycleResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateLifecycleResponse(ctx, r, path)
}

func validate_required_Object_CreateLifecycleResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadLifecycleRequest function validates a JSON for a given object.
func validate_Object_ReadLifecycleRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadLifecycleRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadLifecycleRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadLifecycleRequest.
func (_ *ReadLifecycleRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadLifecycleRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadLifecycleRequest(ctx, r, path)
}

func validate_required_Object_ReadLifecycleRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadLifecycleResponse function validates a JSON for a given object.
func validate_Object_ReadLifecycleResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadLifecycleResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadLifecycleResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Lifecycle(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadLifecycleResponse.
func (_ *ReadLifecycleResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadLifecycleResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadLifecycleResponse(ctx, r, path)
}

func validate_required_Object_ReadLifecycleResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateLifecycleRequest function validates a JSON for a given object.
func validate_Object_UpdateLifecycleRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateLifecycleRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateLifecycleRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Lifecycle(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateLifecycleRequest.
func (_ *UpdateLifecycleRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateLifecycleRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateLifecycleRequest(ctx, r, path)
}

func validate_required_Object_UpdateLifecycleRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateLifecycleResponse function validates a JSON for a given object.
func validate_Object_UpdateLifecycleResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateLifecycleResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateLifecycleResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Lifecycle(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateLifecycleResponse.
func (_ *UpdateLifecycleResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateLifecycleResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateLifecycleResponse(ctx, r, path)
}

func validate_required_Object_UpdateLifecycleResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteLifecycleRequest function validates a JSON for a given object.
func validate_Object_DeleteLifecycleRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteLifecycleRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteLifecycleRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteLifecycleRequest.
func (_ *DeleteLifecycleRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteLifecycleRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteLifecycleRequest(ctx, r, path)
}

func validate_required_Object_DeleteLifecycleRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteLifecycleResponse function validates a JSON for a given object.
func validate_Object_DeleteLifecycleResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteLifecycleResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteLifecycleResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteLifecycleResponse.
func (_ *DeleteLifecycleResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteLifecycleResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteLifecycleResponse(ctx, r, path)
}

func validate_required_Object_DeleteLifecycleResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListLifecycleRequest function validates a JSON for a given object.
func validate_Object_ListLifecycleRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListLifecycleRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListLifecycleRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListLifecycleRequest.
func (_ *ListLifecycleRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListLifecycleRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListLifecycleRequest(ctx, r, path)
}

func validate_required_Object_ListLifecycleRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListLifecyclesResponse function validates a JSON for a given object.
func validate_Object_ListLifecyclesResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListLifecyclesResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListLifecyclesResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Lifecycle(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListLifecyclesResponse.
func (_ *ListLifecyclesResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListLifecyclesResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListLifecyclesResponse(ctx, r, path)
}

func validate_required_Object_ListLifecyclesResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ChartVersion function validates a JSON for a given object.
func validate_Object_ChartVersion(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ChartVersion{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ChartVersion(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "repo":
		case "version":
		case "chart_store":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&types.JSONValue{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "application_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ChartVersion.
func (_ *ChartVersion) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ChartVersion{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ChartVersion(ctx, r, path)
}

func validate_required_Object_ChartVersion(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateChartVersionRequest function validates a JSON for a given object.
func validate_Object_CreateChartVersionRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateChartVersionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateChartVersionRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_ChartVersion(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateChartVersionRequest.
func (_ *CreateChartVersionRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateChartVersionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateChartVersionRequest(ctx, r, path)
}

func validate_required_Object_CreateChartVersionRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateChartVersionResponse function validates a JSON for a given object.
func validate_Object_CreateChartVersionResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateChartVersionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateChartVersionResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_ChartVersion(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateChartVersionResponse.
func (_ *CreateChartVersionResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateChartVersionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateChartVersionResponse(ctx, r, path)
}

func validate_required_Object_CreateChartVersionResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadChartVersionRequest function validates a JSON for a given object.
func validate_Object_ReadChartVersionRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadChartVersionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadChartVersionRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadChartVersionRequest.
func (_ *ReadChartVersionRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadChartVersionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadChartVersionRequest(ctx, r, path)
}

func validate_required_Object_ReadChartVersionRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadChartVersionResponse function validates a JSON for a given object.
func validate_Object_ReadChartVersionResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadChartVersionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadChartVersionResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_ChartVersion(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadChartVersionResponse.
func (_ *ReadChartVersionResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadChartVersionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadChartVersionResponse(ctx, r, path)
}

func validate_required_Object_ReadChartVersionResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateChartVersionRequest function validates a JSON for a given object.
func validate_Object_UpdateChartVersionRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateChartVersionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateChartVersionRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_ChartVersion(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateChartVersionRequest.
func (_ *UpdateChartVersionRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateChartVersionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateChartVersionRequest(ctx, r, path)
}

func validate_required_Object_UpdateChartVersionRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateChartVersionResponse function validates a JSON for a given object.
func validate_Object_UpdateChartVersionResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateChartVersionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateChartVersionResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_ChartVersion(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateChartVersionResponse.
func (_ *UpdateChartVersionResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateChartVersionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateChartVersionResponse(ctx, r, path)
}

func validate_required_Object_UpdateChartVersionResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteChartVersionRequest function validates a JSON for a given object.
func validate_Object_DeleteChartVersionRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteChartVersionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteChartVersionRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteChartVersionRequest.
func (_ *DeleteChartVersionRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteChartVersionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteChartVersionRequest(ctx, r, path)
}

func validate_required_Object_DeleteChartVersionRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteChartVersionResponse function validates a JSON for a given object.
func validate_Object_DeleteChartVersionResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteChartVersionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteChartVersionResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteChartVersionResponse.
func (_ *DeleteChartVersionResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteChartVersionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteChartVersionResponse(ctx, r, path)
}

func validate_required_Object_DeleteChartVersionResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListChartVersionRequest function validates a JSON for a given object.
func validate_Object_ListChartVersionRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListChartVersionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListChartVersionRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListChartVersionRequest.
func (_ *ListChartVersionRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListChartVersionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListChartVersionRequest(ctx, r, path)
}

func validate_required_Object_ListChartVersionRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListChartVersionsResponse function validates a JSON for a given object.
func validate_Object_ListChartVersionsResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListChartVersionsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListChartVersionsResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_ChartVersion(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListChartVersionsResponse.
func (_ *ListChartVersionsResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListChartVersionsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListChartVersionsResponse(ctx, r, path)
}

func validate_required_Object_ListChartVersionsResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_AppConfig function validates a JSON for a given object.
func validate_Object_AppConfig(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&AppConfig{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_AppConfig(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "config_yaml":
		case "application_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "lifecycle_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "environment_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object AppConfig.
func (_ *AppConfig) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&AppConfig{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_AppConfig(ctx, r, path)
}

func validate_required_Object_AppConfig(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateAppConfigRequest function validates a JSON for a given object.
func validate_Object_CreateAppConfigRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateAppConfigRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateAppConfigRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_AppConfig(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateAppConfigRequest.
func (_ *CreateAppConfigRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateAppConfigRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateAppConfigRequest(ctx, r, path)
}

func validate_required_Object_CreateAppConfigRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateAppConfigResponse function validates a JSON for a given object.
func validate_Object_CreateAppConfigResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateAppConfigResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateAppConfigResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_AppConfig(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateAppConfigResponse.
func (_ *CreateAppConfigResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateAppConfigResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateAppConfigResponse(ctx, r, path)
}

func validate_required_Object_CreateAppConfigResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadAppConfigRequest function validates a JSON for a given object.
func validate_Object_ReadAppConfigRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadAppConfigRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadAppConfigRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadAppConfigRequest.
func (_ *ReadAppConfigRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadAppConfigRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadAppConfigRequest(ctx, r, path)
}

func validate_required_Object_ReadAppConfigRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadAppConfigResponse function validates a JSON for a given object.
func validate_Object_ReadAppConfigResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadAppConfigResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadAppConfigResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_AppConfig(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadAppConfigResponse.
func (_ *ReadAppConfigResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadAppConfigResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadAppConfigResponse(ctx, r, path)
}

func validate_required_Object_ReadAppConfigResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateAppConfigRequest function validates a JSON for a given object.
func validate_Object_UpdateAppConfigRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateAppConfigRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateAppConfigRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_AppConfig(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateAppConfigRequest.
func (_ *UpdateAppConfigRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateAppConfigRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateAppConfigRequest(ctx, r, path)
}

func validate_required_Object_UpdateAppConfigRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateAppConfigResponse function validates a JSON for a given object.
func validate_Object_UpdateAppConfigResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateAppConfigResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateAppConfigResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_AppConfig(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateAppConfigResponse.
func (_ *UpdateAppConfigResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateAppConfigResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateAppConfigResponse(ctx, r, path)
}

func validate_required_Object_UpdateAppConfigResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteAppConfigRequest function validates a JSON for a given object.
func validate_Object_DeleteAppConfigRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteAppConfigRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteAppConfigRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteAppConfigRequest.
func (_ *DeleteAppConfigRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteAppConfigRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteAppConfigRequest(ctx, r, path)
}

func validate_required_Object_DeleteAppConfigRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteAppConfigResponse function validates a JSON for a given object.
func validate_Object_DeleteAppConfigResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteAppConfigResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteAppConfigResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteAppConfigResponse.
func (_ *DeleteAppConfigResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteAppConfigResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteAppConfigResponse(ctx, r, path)
}

func validate_required_Object_DeleteAppConfigResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListAppConfigRequest function validates a JSON for a given object.
func validate_Object_ListAppConfigRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListAppConfigRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListAppConfigRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListAppConfigRequest.
func (_ *ListAppConfigRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListAppConfigRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListAppConfigRequest(ctx, r, path)
}

func validate_required_Object_ListAppConfigRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListAppConfigsResponse function validates a JSON for a given object.
func validate_Object_ListAppConfigsResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListAppConfigsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListAppConfigsResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_AppConfig(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListAppConfigsResponse.
func (_ *ListAppConfigsResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListAppConfigsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListAppConfigsResponse(ctx, r, path)
}

func validate_required_Object_ListAppConfigsResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_Environment function validates a JSON for a given object.
func validate_Object_Environment(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Environment{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_Environment(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "config_yaml":
		case "application_instances":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_ApplicationInstance(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "app_config":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_AppConfig(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "app_version":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_AppVersion(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "lifecycle_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object Environment.
func (_ *Environment) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Environment{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_Environment(ctx, r, path)
}

func validate_required_Object_Environment(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateEnvironmentRequest function validates a JSON for a given object.
func validate_Object_CreateEnvironmentRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateEnvironmentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateEnvironmentRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Environment(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateEnvironmentRequest.
func (_ *CreateEnvironmentRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateEnvironmentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateEnvironmentRequest(ctx, r, path)
}

func validate_required_Object_CreateEnvironmentRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateEnvironmentResponse function validates a JSON for a given object.
func validate_Object_CreateEnvironmentResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateEnvironmentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateEnvironmentResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Environment(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateEnvironmentResponse.
func (_ *CreateEnvironmentResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateEnvironmentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateEnvironmentResponse(ctx, r, path)
}

func validate_required_Object_CreateEnvironmentResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadEnvironmentRequest function validates a JSON for a given object.
func validate_Object_ReadEnvironmentRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadEnvironmentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadEnvironmentRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadEnvironmentRequest.
func (_ *ReadEnvironmentRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadEnvironmentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadEnvironmentRequest(ctx, r, path)
}

func validate_required_Object_ReadEnvironmentRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadEnvironmentResponse function validates a JSON for a given object.
func validate_Object_ReadEnvironmentResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadEnvironmentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadEnvironmentResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Environment(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadEnvironmentResponse.
func (_ *ReadEnvironmentResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadEnvironmentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadEnvironmentResponse(ctx, r, path)
}

func validate_required_Object_ReadEnvironmentResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateEnvironmentRequest function validates a JSON for a given object.
func validate_Object_UpdateEnvironmentRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateEnvironmentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateEnvironmentRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Environment(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateEnvironmentRequest.
func (_ *UpdateEnvironmentRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateEnvironmentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateEnvironmentRequest(ctx, r, path)
}

func validate_required_Object_UpdateEnvironmentRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateEnvironmentResponse function validates a JSON for a given object.
func validate_Object_UpdateEnvironmentResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateEnvironmentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateEnvironmentResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Environment(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateEnvironmentResponse.
func (_ *UpdateEnvironmentResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateEnvironmentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateEnvironmentResponse(ctx, r, path)
}

func validate_required_Object_UpdateEnvironmentResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteEnvironmentRequest function validates a JSON for a given object.
func validate_Object_DeleteEnvironmentRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteEnvironmentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteEnvironmentRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteEnvironmentRequest.
func (_ *DeleteEnvironmentRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteEnvironmentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteEnvironmentRequest(ctx, r, path)
}

func validate_required_Object_DeleteEnvironmentRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteEnvironmentResponse function validates a JSON for a given object.
func validate_Object_DeleteEnvironmentResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteEnvironmentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteEnvironmentResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteEnvironmentResponse.
func (_ *DeleteEnvironmentResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteEnvironmentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteEnvironmentResponse(ctx, r, path)
}

func validate_required_Object_DeleteEnvironmentResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListEnvironmentRequest function validates a JSON for a given object.
func validate_Object_ListEnvironmentRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListEnvironmentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListEnvironmentRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListEnvironmentRequest.
func (_ *ListEnvironmentRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListEnvironmentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListEnvironmentRequest(ctx, r, path)
}

func validate_required_Object_ListEnvironmentRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListEnvironmentsResponse function validates a JSON for a given object.
func validate_Object_ListEnvironmentsResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListEnvironmentsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListEnvironmentsResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Environment(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListEnvironmentsResponse.
func (_ *ListEnvironmentsResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListEnvironmentsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListEnvironmentsResponse(ctx, r, path)
}

func validate_required_Object_ListEnvironmentsResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_Application function validates a JSON for a given object.
func validate_Object_Application(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Application{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_Application(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "chart":
		case "repo":
		case "ticket_link":
		case "config_yaml":
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object Application.
func (_ *Application) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Application{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_Application(ctx, r, path)
}

func validate_required_Object_Application(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateApplicationRequest function validates a JSON for a given object.
func validate_Object_CreateApplicationRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateApplicationRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateApplicationRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Application(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateApplicationRequest.
func (_ *CreateApplicationRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateApplicationRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateApplicationRequest(ctx, r, path)
}

func validate_required_Object_CreateApplicationRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateApplicationResponse function validates a JSON for a given object.
func validate_Object_CreateApplicationResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateApplicationResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateApplicationResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Application(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateApplicationResponse.
func (_ *CreateApplicationResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateApplicationResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateApplicationResponse(ctx, r, path)
}

func validate_required_Object_CreateApplicationResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadApplicationRequest function validates a JSON for a given object.
func validate_Object_ReadApplicationRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadApplicationRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadApplicationRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadApplicationRequest.
func (_ *ReadApplicationRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadApplicationRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadApplicationRequest(ctx, r, path)
}

func validate_required_Object_ReadApplicationRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadApplicationResponse function validates a JSON for a given object.
func validate_Object_ReadApplicationResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadApplicationResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadApplicationResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Application(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadApplicationResponse.
func (_ *ReadApplicationResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadApplicationResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadApplicationResponse(ctx, r, path)
}

func validate_required_Object_ReadApplicationResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateApplicationRequest function validates a JSON for a given object.
func validate_Object_UpdateApplicationRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateApplicationRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateApplicationRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Application(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateApplicationRequest.
func (_ *UpdateApplicationRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateApplicationRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateApplicationRequest(ctx, r, path)
}

func validate_required_Object_UpdateApplicationRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateApplicationResponse function validates a JSON for a given object.
func validate_Object_UpdateApplicationResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateApplicationResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateApplicationResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Application(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateApplicationResponse.
func (_ *UpdateApplicationResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateApplicationResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateApplicationResponse(ctx, r, path)
}

func validate_required_Object_UpdateApplicationResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteApplicationRequest function validates a JSON for a given object.
func validate_Object_DeleteApplicationRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteApplicationRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteApplicationRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteApplicationRequest.
func (_ *DeleteApplicationRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteApplicationRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteApplicationRequest(ctx, r, path)
}

func validate_required_Object_DeleteApplicationRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteApplicationResponse function validates a JSON for a given object.
func validate_Object_DeleteApplicationResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteApplicationResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteApplicationResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteApplicationResponse.
func (_ *DeleteApplicationResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteApplicationResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteApplicationResponse(ctx, r, path)
}

func validate_required_Object_DeleteApplicationResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListApplicationRequest function validates a JSON for a given object.
func validate_Object_ListApplicationRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListApplicationRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListApplicationRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListApplicationRequest.
func (_ *ListApplicationRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListApplicationRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListApplicationRequest(ctx, r, path)
}

func validate_required_Object_ListApplicationRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListApplicationsResponse function validates a JSON for a given object.
func validate_Object_ListApplicationsResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListApplicationsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListApplicationsResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Application(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListApplicationsResponse.
func (_ *ListApplicationsResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListApplicationsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListApplicationsResponse(ctx, r, path)
}

func validate_required_Object_ListApplicationsResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_AppVersion function validates a JSON for a given object.
func validate_Object_AppVersion(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&AppVersion{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_AppVersion(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "chart_version":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_ChartVersion(ctx, vv, vvPath); err != nil {
				return err
			}
		case "chart_version_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "application_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "lifecycle_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "environment_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object AppVersion.
func (_ *AppVersion) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&AppVersion{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_AppVersion(ctx, r, path)
}

func validate_required_Object_AppVersion(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateAppVersionRequest function validates a JSON for a given object.
func validate_Object_CreateAppVersionRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateAppVersionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateAppVersionRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_AppVersion(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateAppVersionRequest.
func (_ *CreateAppVersionRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateAppVersionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateAppVersionRequest(ctx, r, path)
}

func validate_required_Object_CreateAppVersionRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateAppVersionResponse function validates a JSON for a given object.
func validate_Object_CreateAppVersionResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateAppVersionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateAppVersionResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_AppVersion(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateAppVersionResponse.
func (_ *CreateAppVersionResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateAppVersionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateAppVersionResponse(ctx, r, path)
}

func validate_required_Object_CreateAppVersionResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadAppVersionRequest function validates a JSON for a given object.
func validate_Object_ReadAppVersionRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadAppVersionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadAppVersionRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadAppVersionRequest.
func (_ *ReadAppVersionRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadAppVersionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadAppVersionRequest(ctx, r, path)
}

func validate_required_Object_ReadAppVersionRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadAppVersionResponse function validates a JSON for a given object.
func validate_Object_ReadAppVersionResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadAppVersionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadAppVersionResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_AppVersion(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadAppVersionResponse.
func (_ *ReadAppVersionResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadAppVersionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadAppVersionResponse(ctx, r, path)
}

func validate_required_Object_ReadAppVersionResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateAppVersionRequest function validates a JSON for a given object.
func validate_Object_UpdateAppVersionRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateAppVersionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateAppVersionRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_AppVersion(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateAppVersionRequest.
func (_ *UpdateAppVersionRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateAppVersionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateAppVersionRequest(ctx, r, path)
}

func validate_required_Object_UpdateAppVersionRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateAppVersionResponse function validates a JSON for a given object.
func validate_Object_UpdateAppVersionResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateAppVersionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateAppVersionResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_AppVersion(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateAppVersionResponse.
func (_ *UpdateAppVersionResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateAppVersionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateAppVersionResponse(ctx, r, path)
}

func validate_required_Object_UpdateAppVersionResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteAppVersionRequest function validates a JSON for a given object.
func validate_Object_DeleteAppVersionRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteAppVersionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteAppVersionRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteAppVersionRequest.
func (_ *DeleteAppVersionRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteAppVersionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteAppVersionRequest(ctx, r, path)
}

func validate_required_Object_DeleteAppVersionRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteAppVersionResponse function validates a JSON for a given object.
func validate_Object_DeleteAppVersionResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteAppVersionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteAppVersionResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteAppVersionResponse.
func (_ *DeleteAppVersionResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteAppVersionResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteAppVersionResponse(ctx, r, path)
}

func validate_required_Object_DeleteAppVersionResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListAppVersionRequest function validates a JSON for a given object.
func validate_Object_ListAppVersionRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListAppVersionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListAppVersionRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListAppVersionRequest.
func (_ *ListAppVersionRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListAppVersionRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListAppVersionRequest(ctx, r, path)
}

func validate_required_Object_ListAppVersionRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListAppVersionsResponse function validates a JSON for a given object.
func validate_Object_ListAppVersionsResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListAppVersionsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListAppVersionsResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_AppVersion(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListAppVersionsResponse.
func (_ *ListAppVersionsResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListAppVersionsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListAppVersionsResponse(ctx, r, path)
}

func validate_required_Object_ListAppVersionsResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ApplicationInstance function validates a JSON for a given object.
func validate_Object_ApplicationInstance(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ApplicationInstance{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ApplicationInstance(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "deployment":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Deployment(ctx, vv, vvPath); err != nil {
				return err
			}
		case "config_yaml":
		case "chart_version":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_ChartVersion(ctx, vv, vvPath); err != nil {
				return err
			}
		case "chart_version_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "environment_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "application_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ApplicationInstance.
func (_ *ApplicationInstance) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ApplicationInstance{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ApplicationInstance(ctx, r, path)
}

func validate_required_Object_ApplicationInstance(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateApplicationInstanceRequest function validates a JSON for a given object.
func validate_Object_CreateApplicationInstanceRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateApplicationInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateApplicationInstanceRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_ApplicationInstance(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateApplicationInstanceRequest.
func (_ *CreateApplicationInstanceRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateApplicationInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateApplicationInstanceRequest(ctx, r, path)
}

func validate_required_Object_CreateApplicationInstanceRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateApplicationInstanceResponse function validates a JSON for a given object.
func validate_Object_CreateApplicationInstanceResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateApplicationInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateApplicationInstanceResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_ApplicationInstance(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateApplicationInstanceResponse.
func (_ *CreateApplicationInstanceResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateApplicationInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateApplicationInstanceResponse(ctx, r, path)
}

func validate_required_Object_CreateApplicationInstanceResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadApplicationInstanceRequest function validates a JSON for a given object.
func validate_Object_ReadApplicationInstanceRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadApplicationInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadApplicationInstanceRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadApplicationInstanceRequest.
func (_ *ReadApplicationInstanceRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadApplicationInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadApplicationInstanceRequest(ctx, r, path)
}

func validate_required_Object_ReadApplicationInstanceRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadApplicationInstanceResponse function validates a JSON for a given object.
func validate_Object_ReadApplicationInstanceResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadApplicationInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadApplicationInstanceResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_ApplicationInstance(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadApplicationInstanceResponse.
func (_ *ReadApplicationInstanceResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadApplicationInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadApplicationInstanceResponse(ctx, r, path)
}

func validate_required_Object_ReadApplicationInstanceResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateApplicationInstanceRequest function validates a JSON for a given object.
func validate_Object_UpdateApplicationInstanceRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateApplicationInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateApplicationInstanceRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_ApplicationInstance(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateApplicationInstanceRequest.
func (_ *UpdateApplicationInstanceRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateApplicationInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateApplicationInstanceRequest(ctx, r, path)
}

func validate_required_Object_UpdateApplicationInstanceRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateApplicationInstanceResponse function validates a JSON for a given object.
func validate_Object_UpdateApplicationInstanceResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateApplicationInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateApplicationInstanceResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_ApplicationInstance(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateApplicationInstanceResponse.
func (_ *UpdateApplicationInstanceResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateApplicationInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateApplicationInstanceResponse(ctx, r, path)
}

func validate_required_Object_UpdateApplicationInstanceResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteApplicationInstanceRequest function validates a JSON for a given object.
func validate_Object_DeleteApplicationInstanceRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteApplicationInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteApplicationInstanceRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteApplicationInstanceRequest.
func (_ *DeleteApplicationInstanceRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteApplicationInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteApplicationInstanceRequest(ctx, r, path)
}

func validate_required_Object_DeleteApplicationInstanceRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteApplicationInstanceResponse function validates a JSON for a given object.
func validate_Object_DeleteApplicationInstanceResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteApplicationInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteApplicationInstanceResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteApplicationInstanceResponse.
func (_ *DeleteApplicationInstanceResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteApplicationInstanceResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteApplicationInstanceResponse(ctx, r, path)
}

func validate_required_Object_DeleteApplicationInstanceResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListApplicationInstanceRequest function validates a JSON for a given object.
func validate_Object_ListApplicationInstanceRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListApplicationInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListApplicationInstanceRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListApplicationInstanceRequest.
func (_ *ListApplicationInstanceRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListApplicationInstanceRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListApplicationInstanceRequest(ctx, r, path)
}

func validate_required_Object_ListApplicationInstanceRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListApplicationInstancesResponse function validates a JSON for a given object.
func validate_Object_ListApplicationInstancesResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListApplicationInstancesResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListApplicationInstancesResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_ApplicationInstance(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListApplicationInstancesResponse.
func (_ *ListApplicationInstancesResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListApplicationInstancesResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListApplicationInstancesResponse(ctx, r, path)
}

func validate_required_Object_ListApplicationInstancesResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_Vault function validates a JSON for a given object.
func validate_Object_Vault(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Vault{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_Vault(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "secrets":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Secret(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object Vault.
func (_ *Vault) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Vault{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_Vault(ctx, r, path)
}

func validate_required_Object_Vault(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateVaultRequest function validates a JSON for a given object.
func validate_Object_CreateVaultRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateVaultRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateVaultRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Vault(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateVaultRequest.
func (_ *CreateVaultRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateVaultRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateVaultRequest(ctx, r, path)
}

func validate_required_Object_CreateVaultRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateVaultResponse function validates a JSON for a given object.
func validate_Object_CreateVaultResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateVaultResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateVaultResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Vault(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateVaultResponse.
func (_ *CreateVaultResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateVaultResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateVaultResponse(ctx, r, path)
}

func validate_required_Object_CreateVaultResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadVaultRequest function validates a JSON for a given object.
func validate_Object_ReadVaultRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadVaultRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadVaultRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadVaultRequest.
func (_ *ReadVaultRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadVaultRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadVaultRequest(ctx, r, path)
}

func validate_required_Object_ReadVaultRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadVaultResponse function validates a JSON for a given object.
func validate_Object_ReadVaultResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadVaultResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadVaultResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Vault(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadVaultResponse.
func (_ *ReadVaultResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadVaultResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadVaultResponse(ctx, r, path)
}

func validate_required_Object_ReadVaultResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateVaultRequest function validates a JSON for a given object.
func validate_Object_UpdateVaultRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateVaultRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateVaultRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Vault(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateVaultRequest.
func (_ *UpdateVaultRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateVaultRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateVaultRequest(ctx, r, path)
}

func validate_required_Object_UpdateVaultRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateVaultResponse function validates a JSON for a given object.
func validate_Object_UpdateVaultResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateVaultResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateVaultResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Vault(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateVaultResponse.
func (_ *UpdateVaultResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateVaultResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateVaultResponse(ctx, r, path)
}

func validate_required_Object_UpdateVaultResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteVaultRequest function validates a JSON for a given object.
func validate_Object_DeleteVaultRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteVaultRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteVaultRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteVaultRequest.
func (_ *DeleteVaultRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteVaultRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteVaultRequest(ctx, r, path)
}

func validate_required_Object_DeleteVaultRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteVaultResponse function validates a JSON for a given object.
func validate_Object_DeleteVaultResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteVaultResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteVaultResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteVaultResponse.
func (_ *DeleteVaultResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteVaultResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteVaultResponse(ctx, r, path)
}

func validate_required_Object_DeleteVaultResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListVaultRequest function validates a JSON for a given object.
func validate_Object_ListVaultRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListVaultRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListVaultRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListVaultRequest.
func (_ *ListVaultRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListVaultRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListVaultRequest(ctx, r, path)
}

func validate_required_Object_ListVaultRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListVaultsResponse function validates a JSON for a given object.
func validate_Object_ListVaultsResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListVaultsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListVaultsResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Vault(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListVaultsResponse.
func (_ *ListVaultsResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListVaultsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListVaultsResponse(ctx, r, path)
}

func validate_required_Object_ListVaultsResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_Secret function validates a JSON for a given object.
func validate_Object_Secret(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Secret{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_Secret(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "path":
		case "type":
		case "key":
		case "vault_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object Secret.
func (_ *Secret) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Secret{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_Secret(ctx, r, path)
}

func validate_required_Object_Secret(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateSecretRequest function validates a JSON for a given object.
func validate_Object_CreateSecretRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateSecretRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateSecretRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Secret(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateSecretRequest.
func (_ *CreateSecretRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateSecretRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateSecretRequest(ctx, r, path)
}

func validate_required_Object_CreateSecretRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateSecretResponse function validates a JSON for a given object.
func validate_Object_CreateSecretResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateSecretResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateSecretResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Secret(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateSecretResponse.
func (_ *CreateSecretResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateSecretResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateSecretResponse(ctx, r, path)
}

func validate_required_Object_CreateSecretResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadSecretRequest function validates a JSON for a given object.
func validate_Object_ReadSecretRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadSecretRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadSecretRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadSecretRequest.
func (_ *ReadSecretRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadSecretRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadSecretRequest(ctx, r, path)
}

func validate_required_Object_ReadSecretRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadSecretResponse function validates a JSON for a given object.
func validate_Object_ReadSecretResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadSecretResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadSecretResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Secret(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadSecretResponse.
func (_ *ReadSecretResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadSecretResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadSecretResponse(ctx, r, path)
}

func validate_required_Object_ReadSecretResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateSecretRequest function validates a JSON for a given object.
func validate_Object_UpdateSecretRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateSecretRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateSecretRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Secret(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateSecretRequest.
func (_ *UpdateSecretRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateSecretRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateSecretRequest(ctx, r, path)
}

func validate_required_Object_UpdateSecretRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateSecretResponse function validates a JSON for a given object.
func validate_Object_UpdateSecretResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateSecretResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateSecretResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Secret(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateSecretResponse.
func (_ *UpdateSecretResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateSecretResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateSecretResponse(ctx, r, path)
}

func validate_required_Object_UpdateSecretResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteSecretRequest function validates a JSON for a given object.
func validate_Object_DeleteSecretRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteSecretRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteSecretRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteSecretRequest.
func (_ *DeleteSecretRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteSecretRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteSecretRequest(ctx, r, path)
}

func validate_required_Object_DeleteSecretRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteSecretResponse function validates a JSON for a given object.
func validate_Object_DeleteSecretResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteSecretResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteSecretResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteSecretResponse.
func (_ *DeleteSecretResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteSecretResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteSecretResponse(ctx, r, path)
}

func validate_required_Object_DeleteSecretResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListSecretRequest function validates a JSON for a given object.
func validate_Object_ListSecretRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListSecretRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListSecretRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListSecretRequest.
func (_ *ListSecretRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListSecretRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListSecretRequest(ctx, r, path)
}

func validate_required_Object_ListSecretRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListSecretsResponse function validates a JSON for a given object.
func validate_Object_ListSecretsResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListSecretsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListSecretsResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Secret(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListSecretsResponse.
func (_ *ListSecretsResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListSecretsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListSecretsResponse(ctx, r, path)
}

func validate_required_Object_ListSecretsResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_Artifact function validates a JSON for a given object.
func validate_Object_Artifact(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Artifact{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_Artifact(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "repo":
		case "commit":
		case "chart_version_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object Artifact.
func (_ *Artifact) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Artifact{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_Artifact(ctx, r, path)
}

func validate_required_Object_Artifact(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateArtifactRequest function validates a JSON for a given object.
func validate_Object_CreateArtifactRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateArtifactRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateArtifactRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Artifact(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateArtifactRequest.
func (_ *CreateArtifactRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateArtifactRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateArtifactRequest(ctx, r, path)
}

func validate_required_Object_CreateArtifactRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateArtifactResponse function validates a JSON for a given object.
func validate_Object_CreateArtifactResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateArtifactResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateArtifactResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Artifact(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateArtifactResponse.
func (_ *CreateArtifactResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateArtifactResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateArtifactResponse(ctx, r, path)
}

func validate_required_Object_CreateArtifactResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadArtifactRequest function validates a JSON for a given object.
func validate_Object_ReadArtifactRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadArtifactRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadArtifactRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadArtifactRequest.
func (_ *ReadArtifactRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadArtifactRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadArtifactRequest(ctx, r, path)
}

func validate_required_Object_ReadArtifactRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadArtifactResponse function validates a JSON for a given object.
func validate_Object_ReadArtifactResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadArtifactResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadArtifactResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Artifact(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadArtifactResponse.
func (_ *ReadArtifactResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadArtifactResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadArtifactResponse(ctx, r, path)
}

func validate_required_Object_ReadArtifactResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateArtifactRequest function validates a JSON for a given object.
func validate_Object_UpdateArtifactRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateArtifactRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateArtifactRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Artifact(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateArtifactRequest.
func (_ *UpdateArtifactRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateArtifactRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateArtifactRequest(ctx, r, path)
}

func validate_required_Object_UpdateArtifactRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateArtifactResponse function validates a JSON for a given object.
func validate_Object_UpdateArtifactResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateArtifactResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateArtifactResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Artifact(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateArtifactResponse.
func (_ *UpdateArtifactResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateArtifactResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateArtifactResponse(ctx, r, path)
}

func validate_required_Object_UpdateArtifactResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteArtifactRequest function validates a JSON for a given object.
func validate_Object_DeleteArtifactRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteArtifactRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteArtifactRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteArtifactRequest.
func (_ *DeleteArtifactRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteArtifactRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteArtifactRequest(ctx, r, path)
}

func validate_required_Object_DeleteArtifactRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteArtifactResponse function validates a JSON for a given object.
func validate_Object_DeleteArtifactResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteArtifactResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteArtifactResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteArtifactResponse.
func (_ *DeleteArtifactResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteArtifactResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteArtifactResponse(ctx, r, path)
}

func validate_required_Object_DeleteArtifactResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListArtifactRequest function validates a JSON for a given object.
func validate_Object_ListArtifactRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListArtifactRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListArtifactRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListArtifactRequest.
func (_ *ListArtifactRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListArtifactRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListArtifactRequest(ctx, r, path)
}

func validate_required_Object_ListArtifactRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListArtifactsResponse function validates a JSON for a given object.
func validate_Object_ListArtifactsResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListArtifactsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListArtifactsResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Artifact(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListArtifactsResponse.
func (_ *ListArtifactsResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListArtifactsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListArtifactsResponse(ctx, r, path)
}

func validate_required_Object_ListArtifactsResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_KubeCluster function validates a JSON for a given object.
func validate_Object_KubeCluster(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&KubeCluster{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_KubeCluster(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "network_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object KubeCluster.
func (_ *KubeCluster) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&KubeCluster{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_KubeCluster(ctx, r, path)
}

func validate_required_Object_KubeCluster(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateKubeClusterRequest function validates a JSON for a given object.
func validate_Object_CreateKubeClusterRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateKubeClusterRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateKubeClusterRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_KubeCluster(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateKubeClusterRequest.
func (_ *CreateKubeClusterRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateKubeClusterRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateKubeClusterRequest(ctx, r, path)
}

func validate_required_Object_CreateKubeClusterRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateKubeClusterResponse function validates a JSON for a given object.
func validate_Object_CreateKubeClusterResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateKubeClusterResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateKubeClusterResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_KubeCluster(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateKubeClusterResponse.
func (_ *CreateKubeClusterResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateKubeClusterResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateKubeClusterResponse(ctx, r, path)
}

func validate_required_Object_CreateKubeClusterResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadKubeClusterRequest function validates a JSON for a given object.
func validate_Object_ReadKubeClusterRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadKubeClusterRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadKubeClusterRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadKubeClusterRequest.
func (_ *ReadKubeClusterRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadKubeClusterRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadKubeClusterRequest(ctx, r, path)
}

func validate_required_Object_ReadKubeClusterRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadKubeClusterResponse function validates a JSON for a given object.
func validate_Object_ReadKubeClusterResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadKubeClusterResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadKubeClusterResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_KubeCluster(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadKubeClusterResponse.
func (_ *ReadKubeClusterResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadKubeClusterResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadKubeClusterResponse(ctx, r, path)
}

func validate_required_Object_ReadKubeClusterResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateKubeClusterRequest function validates a JSON for a given object.
func validate_Object_UpdateKubeClusterRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateKubeClusterRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateKubeClusterRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_KubeCluster(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateKubeClusterRequest.
func (_ *UpdateKubeClusterRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateKubeClusterRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateKubeClusterRequest(ctx, r, path)
}

func validate_required_Object_UpdateKubeClusterRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateKubeClusterResponse function validates a JSON for a given object.
func validate_Object_UpdateKubeClusterResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateKubeClusterResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateKubeClusterResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_KubeCluster(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateKubeClusterResponse.
func (_ *UpdateKubeClusterResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateKubeClusterResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateKubeClusterResponse(ctx, r, path)
}

func validate_required_Object_UpdateKubeClusterResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteKubeClusterRequest function validates a JSON for a given object.
func validate_Object_DeleteKubeClusterRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteKubeClusterRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteKubeClusterRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteKubeClusterRequest.
func (_ *DeleteKubeClusterRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteKubeClusterRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteKubeClusterRequest(ctx, r, path)
}

func validate_required_Object_DeleteKubeClusterRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteKubeClusterResponse function validates a JSON for a given object.
func validate_Object_DeleteKubeClusterResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteKubeClusterResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteKubeClusterResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteKubeClusterResponse.
func (_ *DeleteKubeClusterResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteKubeClusterResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteKubeClusterResponse(ctx, r, path)
}

func validate_required_Object_DeleteKubeClusterResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListKubeClusterRequest function validates a JSON for a given object.
func validate_Object_ListKubeClusterRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListKubeClusterRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListKubeClusterRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListKubeClusterRequest.
func (_ *ListKubeClusterRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListKubeClusterRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListKubeClusterRequest(ctx, r, path)
}

func validate_required_Object_ListKubeClusterRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListKubeClustersResponse function validates a JSON for a given object.
func validate_Object_ListKubeClustersResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListKubeClustersResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListKubeClustersResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_KubeCluster(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListKubeClustersResponse.
func (_ *ListKubeClustersResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListKubeClustersResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListKubeClustersResponse(ctx, r, path)
}

func validate_required_Object_ListKubeClustersResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_Deployment function validates a JSON for a given object.
func validate_Object_Deployment(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Deployment{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_Deployment(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "name":
		case "description":
		case "artifact":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Artifact(ctx, vv, vvPath); err != nil {
				return err
			}
		case "artifact_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "kube_cluster":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_KubeCluster(ctx, vv, vvPath); err != nil {
				return err
			}
		case "kube_cluster_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "application_instance_id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object Deployment.
func (_ *Deployment) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&Deployment{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_Deployment(ctx, r, path)
}

func validate_required_Object_Deployment(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateDeploymentRequest function validates a JSON for a given object.
func validate_Object_CreateDeploymentRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateDeploymentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateDeploymentRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Deployment(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateDeploymentRequest.
func (_ *CreateDeploymentRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateDeploymentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateDeploymentRequest(ctx, r, path)
}

func validate_required_Object_CreateDeploymentRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_CreateDeploymentResponse function validates a JSON for a given object.
func validate_Object_CreateDeploymentResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateDeploymentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_CreateDeploymentResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Deployment(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object CreateDeploymentResponse.
func (_ *CreateDeploymentResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&CreateDeploymentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_CreateDeploymentResponse(ctx, r, path)
}

func validate_required_Object_CreateDeploymentResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadDeploymentRequest function validates a JSON for a given object.
func validate_Object_ReadDeploymentRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadDeploymentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadDeploymentRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadDeploymentRequest.
func (_ *ReadDeploymentRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadDeploymentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadDeploymentRequest(ctx, r, path)
}

func validate_required_Object_ReadDeploymentRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ReadDeploymentResponse function validates a JSON for a given object.
func validate_Object_ReadDeploymentResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadDeploymentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ReadDeploymentResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Deployment(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ReadDeploymentResponse.
func (_ *ReadDeploymentResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ReadDeploymentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ReadDeploymentResponse(ctx, r, path)
}

func validate_required_Object_ReadDeploymentResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateDeploymentRequest function validates a JSON for a given object.
func validate_Object_UpdateDeploymentRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateDeploymentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateDeploymentRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "payload":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Deployment(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&field_mask.FieldMask{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateDeploymentRequest.
func (_ *UpdateDeploymentRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateDeploymentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateDeploymentRequest(ctx, r, path)
}

func validate_required_Object_UpdateDeploymentRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_UpdateDeploymentResponse function validates a JSON for a given object.
func validate_Object_UpdateDeploymentResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateDeploymentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_UpdateDeploymentResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "result":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			if err = validate_Object_Deployment(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object UpdateDeploymentResponse.
func (_ *UpdateDeploymentResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&UpdateDeploymentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_UpdateDeploymentResponse(ctx, r, path)
}

func validate_required_Object_UpdateDeploymentResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteDeploymentRequest function validates a JSON for a given object.
func validate_Object_DeleteDeploymentRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteDeploymentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteDeploymentRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "id":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&resource.Identifier{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteDeploymentRequest.
func (_ *DeleteDeploymentRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteDeploymentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteDeploymentRequest(ctx, r, path)
}

func validate_required_Object_DeleteDeploymentRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_DeleteDeploymentResponse function validates a JSON for a given object.
func validate_Object_DeleteDeploymentResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteDeploymentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_DeleteDeploymentResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object DeleteDeploymentResponse.
func (_ *DeleteDeploymentResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&DeleteDeploymentResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_DeleteDeploymentResponse(ctx, r, path)
}

func validate_required_Object_DeleteDeploymentResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListDeploymentRequest function validates a JSON for a given object.
func validate_Object_ListDeploymentRequest(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListDeploymentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListDeploymentRequest(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "filter":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Filtering{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "order_by":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Sorting{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "fields":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.FieldSelection{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		case "paging":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.Pagination{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListDeploymentRequest.
func (_ *ListDeploymentRequest) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListDeploymentRequest{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListDeploymentRequest(ctx, r, path)
}

func validate_required_Object_ListDeploymentRequest(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

// validate_Object_ListDeploymentsResponse function validates a JSON for a given object.
func validate_Object_ListDeploymentsResponse(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListDeploymentsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}

	var v map[string]json.RawMessage
	if err = json.Unmarshal(r, &v); err != nil {
		return fmt.Errorf("invalid value for %q: expected object.", path)
	}

	if err = validate_required_Object_ListDeploymentsResponse(ctx, v, path); err != nil {
		return err
	}

	allowUnknown := runtime1.AllowUnknownFromContext(ctx)

	for k, _ := range v {
		switch k {
		case "results":
			if v[k] == nil {
				continue
			}
			var vArr []json.RawMessage
			vArrPath := runtime1.JoinPath(path, k)
			if err = json.Unmarshal(v[k], &vArr); err != nil {
				return fmt.Errorf("invalid value for %q: expected array.", vArrPath)
			}
			for i, vv := range vArr {
				vvPath := fmt.Sprintf("%s.[%d]", vArrPath, i)
				if err = validate_Object_Deployment(ctx, vv, vvPath); err != nil {
					return err
				}
			}
		case "page":
			if v[k] == nil {
				continue
			}
			vv := v[k]
			vvPath := runtime1.JoinPath(path, k)
			validator, ok := interface{}(&query.PageInfo{}).(interface {
				AtlasValidateJSON(context.Context, json.RawMessage, string) error
			})
			if !ok {
				continue
			}
			if err = validator.AtlasValidateJSON(ctx, vv, vvPath); err != nil {
				return err
			}
		default:
			if !allowUnknown {
				return fmt.Errorf("unknown field %q.", runtime1.JoinPath(path, k))
			}
		}
	}
	return nil
}

// AtlasValidateJSON function validates a JSON for object ListDeploymentsResponse.
func (_ *ListDeploymentsResponse) AtlasValidateJSON(ctx context.Context, r json.RawMessage, path string) (err error) {
	if hook, ok := interface{}(&ListDeploymentsResponse{}).(interface {
		AtlasJSONValidate(context.Context, json.RawMessage, string) (json.RawMessage, error)
	}); ok {
		if r, err = hook.AtlasJSONValidate(ctx, r, path); err != nil {
			return err
		}
	}
	return validate_Object_ListDeploymentsResponse(ctx, r, path)
}

func validate_required_Object_ListDeploymentsResponse(ctx context.Context, v map[string]json.RawMessage, path string) error {
	method := runtime1.HTTPMethodFromContext(ctx)
	_ = method
	return nil
}

var validate_Patterns = []struct {
	pattern    runtime.Pattern
	httpMethod string
	validator  func(context.Context, json.RawMessage) error
	// Included for introspection purpose.
	allowUnknown bool
}{
	// patterns for file github.com/seizadi/cmdb/pkg/pb/cmdb.proto
	{
		pattern:      pattern_Cmdb_GetVersion_0,
		httpMethod:   "GET",
		validator:    validate_Cmdb_GetVersion_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_CloudProviders_Create_0,
		httpMethod:   "POST",
		validator:    validate_CloudProviders_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_CloudProviders_Read_0,
		httpMethod:   "GET",
		validator:    validate_CloudProviders_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_CloudProviders_Update_0,
		httpMethod:   "PUT",
		validator:    validate_CloudProviders_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_CloudProviders_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_CloudProviders_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_CloudProviders_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_CloudProviders_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_CloudProviders_List_0,
		httpMethod:   "GET",
		validator:    validate_CloudProviders_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Regions_Create_0,
		httpMethod:   "POST",
		validator:    validate_Regions_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Regions_Read_0,
		httpMethod:   "GET",
		validator:    validate_Regions_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Regions_Update_0,
		httpMethod:   "PUT",
		validator:    validate_Regions_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Regions_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_Regions_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Regions_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_Regions_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Regions_List_0,
		httpMethod:   "GET",
		validator:    validate_Regions_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Networks_Create_0,
		httpMethod:   "POST",
		validator:    validate_Networks_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Networks_Read_0,
		httpMethod:   "GET",
		validator:    validate_Networks_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Networks_Update_0,
		httpMethod:   "PUT",
		validator:    validate_Networks_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Networks_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_Networks_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Networks_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_Networks_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Networks_List_0,
		httpMethod:   "GET",
		validator:    validate_Networks_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Lifecycles_Create_0,
		httpMethod:   "POST",
		validator:    validate_Lifecycles_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Lifecycles_Read_0,
		httpMethod:   "GET",
		validator:    validate_Lifecycles_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Lifecycles_Update_0,
		httpMethod:   "PUT",
		validator:    validate_Lifecycles_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Lifecycles_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_Lifecycles_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Lifecycles_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_Lifecycles_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Lifecycles_List_0,
		httpMethod:   "GET",
		validator:    validate_Lifecycles_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_ChartVersions_Create_0,
		httpMethod:   "POST",
		validator:    validate_ChartVersions_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_ChartVersions_Read_0,
		httpMethod:   "GET",
		validator:    validate_ChartVersions_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_ChartVersions_Update_0,
		httpMethod:   "PUT",
		validator:    validate_ChartVersions_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_ChartVersions_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_ChartVersions_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_ChartVersions_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_ChartVersions_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_ChartVersions_List_0,
		httpMethod:   "GET",
		validator:    validate_ChartVersions_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AppConfigs_Create_0,
		httpMethod:   "POST",
		validator:    validate_AppConfigs_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AppConfigs_Read_0,
		httpMethod:   "GET",
		validator:    validate_AppConfigs_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AppConfigs_Update_0,
		httpMethod:   "PUT",
		validator:    validate_AppConfigs_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AppConfigs_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_AppConfigs_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AppConfigs_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_AppConfigs_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AppConfigs_List_0,
		httpMethod:   "GET",
		validator:    validate_AppConfigs_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Environments_Create_0,
		httpMethod:   "POST",
		validator:    validate_Environments_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Environments_Read_0,
		httpMethod:   "GET",
		validator:    validate_Environments_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Environments_Update_0,
		httpMethod:   "PUT",
		validator:    validate_Environments_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Environments_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_Environments_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Environments_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_Environments_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Environments_List_0,
		httpMethod:   "GET",
		validator:    validate_Environments_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Applications_Create_0,
		httpMethod:   "POST",
		validator:    validate_Applications_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Applications_Read_0,
		httpMethod:   "GET",
		validator:    validate_Applications_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Applications_Update_0,
		httpMethod:   "PUT",
		validator:    validate_Applications_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Applications_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_Applications_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Applications_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_Applications_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Applications_List_0,
		httpMethod:   "GET",
		validator:    validate_Applications_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AppVersions_Create_0,
		httpMethod:   "POST",
		validator:    validate_AppVersions_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AppVersions_Read_0,
		httpMethod:   "GET",
		validator:    validate_AppVersions_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AppVersions_Update_0,
		httpMethod:   "PUT",
		validator:    validate_AppVersions_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AppVersions_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_AppVersions_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AppVersions_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_AppVersions_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_AppVersions_List_0,
		httpMethod:   "GET",
		validator:    validate_AppVersions_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_ApplicationInstances_Create_0,
		httpMethod:   "POST",
		validator:    validate_ApplicationInstances_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_ApplicationInstances_Read_0,
		httpMethod:   "GET",
		validator:    validate_ApplicationInstances_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_ApplicationInstances_Update_0,
		httpMethod:   "PUT",
		validator:    validate_ApplicationInstances_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_ApplicationInstances_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_ApplicationInstances_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_ApplicationInstances_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_ApplicationInstances_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_ApplicationInstances_List_0,
		httpMethod:   "GET",
		validator:    validate_ApplicationInstances_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Vaults_Create_0,
		httpMethod:   "POST",
		validator:    validate_Vaults_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Vaults_Read_0,
		httpMethod:   "GET",
		validator:    validate_Vaults_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Vaults_Update_0,
		httpMethod:   "PUT",
		validator:    validate_Vaults_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Vaults_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_Vaults_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Vaults_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_Vaults_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Vaults_List_0,
		httpMethod:   "GET",
		validator:    validate_Vaults_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Secrets_Create_0,
		httpMethod:   "POST",
		validator:    validate_Secrets_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Secrets_Read_0,
		httpMethod:   "GET",
		validator:    validate_Secrets_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Secrets_Update_0,
		httpMethod:   "PUT",
		validator:    validate_Secrets_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Secrets_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_Secrets_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Secrets_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_Secrets_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Secrets_List_0,
		httpMethod:   "GET",
		validator:    validate_Secrets_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Artifacts_Create_0,
		httpMethod:   "POST",
		validator:    validate_Artifacts_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Artifacts_Read_0,
		httpMethod:   "GET",
		validator:    validate_Artifacts_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Artifacts_Update_0,
		httpMethod:   "PUT",
		validator:    validate_Artifacts_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Artifacts_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_Artifacts_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Artifacts_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_Artifacts_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Artifacts_List_0,
		httpMethod:   "GET",
		validator:    validate_Artifacts_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_KubeClusters_Create_0,
		httpMethod:   "POST",
		validator:    validate_KubeClusters_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_KubeClusters_Read_0,
		httpMethod:   "GET",
		validator:    validate_KubeClusters_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_KubeClusters_Update_0,
		httpMethod:   "PUT",
		validator:    validate_KubeClusters_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_KubeClusters_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_KubeClusters_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_KubeClusters_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_KubeClusters_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_KubeClusters_List_0,
		httpMethod:   "GET",
		validator:    validate_KubeClusters_List_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Deployments_Create_0,
		httpMethod:   "POST",
		validator:    validate_Deployments_Create_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Deployments_Read_0,
		httpMethod:   "GET",
		validator:    validate_Deployments_Read_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Deployments_Update_0,
		httpMethod:   "PUT",
		validator:    validate_Deployments_Update_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Deployments_Update_1,
		httpMethod:   "PATCH",
		validator:    validate_Deployments_Update_1,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Deployments_Delete_0,
		httpMethod:   "DELETE",
		validator:    validate_Deployments_Delete_0,
		allowUnknown: false,
	},
	{
		pattern:      pattern_Deployments_List_0,
		httpMethod:   "GET",
		validator:    validate_Deployments_List_0,
		allowUnknown: false,
	},
}

// AtlasValidateAnnotator parses JSON input and validates unknown fields
// based on 'allow_unknown_fields' options specified in proto file.
func AtlasValidateAnnotator(ctx context.Context, r *http.Request) metadata.MD {
	md := make(metadata.MD)
	for _, v := range validate_Patterns {
		if r.Method == v.httpMethod && runtime1.PatternMatch(v.pattern, r.URL.Path) {
			var b []byte
			var err error
			if b, err = ioutil.ReadAll(r.Body); err != nil {
				md.Set("Atlas-Validation-Error", "invalid value: unable to parse body")
				return md
			}
			r.Body = ioutil.NopCloser(bytes.NewReader(b))
			ctx := context.WithValue(context.WithValue(context.Background(), runtime1.HTTPMethodContextKey, r.Method), runtime1.AllowUnknownContextKey, v.allowUnknown)
			if err = v.validator(ctx, b); err != nil {
				md.Set("Atlas-Validation-Error", err.Error())
			}
			break
		}
	}
	return md
}
