// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/seizadi/cmdb/pkg/pb/cmdb.proto

// Generated with protoc-gen-gorm version: master
// Anticipating compatibility with atlas-app-toolkit version: master

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	github.com/seizadi/cmdb/pkg/pb/cmdb.proto

It has these top-level messages:
	VersionResponse
	CloudProvider
	CreateCloudProviderRequest
	CreateCloudProviderResponse
	ReadCloudProviderRequest
	ReadCloudProviderResponse
	UpdateCloudProviderRequest
	UpdateCloudProviderResponse
	DeleteCloudProviderRequest
	DeleteCloudProviderResponse
	ListCloudProviderRequest
	ListCloudProvidersResponse
	Region
	CreateRegionRequest
	CreateRegionResponse
	ReadRegionRequest
	ReadRegionResponse
	UpdateRegionRequest
	UpdateRegionResponse
	DeleteRegionRequest
	DeleteRegionResponse
	ListRegionRequest
	ListRegionsResponse
	Network
	CreateNetworkRequest
	CreateNetworkResponse
	ReadNetworkRequest
	ReadNetworkResponse
	UpdateNetworkRequest
	UpdateNetworkResponse
	DeleteNetworkRequest
	DeleteNetworkResponse
	ListNetworkRequest
	ListNetworksResponse
	Lifecycle
	CreateLifecycleRequest
	CreateLifecycleResponse
	ReadLifecycleRequest
	ReadLifecycleResponse
	UpdateLifecycleRequest
	UpdateLifecycleResponse
	DeleteLifecycleRequest
	DeleteLifecycleResponse
	ListLifecycleRequest
	ListLifecyclesResponse
	ChartVersion
	CreateChartVersionRequest
	CreateChartVersionResponse
	ReadChartVersionRequest
	ReadChartVersionResponse
	UpdateChartVersionRequest
	UpdateChartVersionResponse
	DeleteChartVersionRequest
	DeleteChartVersionResponse
	ListChartVersionRequest
	ListChartVersionsResponse
	AppConfig
	CreateAppConfigRequest
	CreateAppConfigResponse
	ReadAppConfigRequest
	ReadAppConfigResponse
	UpdateAppConfigRequest
	UpdateAppConfigResponse
	DeleteAppConfigRequest
	DeleteAppConfigResponse
	ListAppConfigRequest
	ListAppConfigsResponse
	Environment
	CreateEnvironmentRequest
	CreateEnvironmentResponse
	ReadEnvironmentRequest
	ReadEnvironmentResponse
	UpdateEnvironmentRequest
	UpdateEnvironmentResponse
	DeleteEnvironmentRequest
	DeleteEnvironmentResponse
	ListEnvironmentRequest
	ListEnvironmentsResponse
	Application
	CreateApplicationRequest
	CreateApplicationResponse
	ReadApplicationRequest
	ReadApplicationResponse
	UpdateApplicationRequest
	UpdateApplicationResponse
	DeleteApplicationRequest
	DeleteApplicationResponse
	ListApplicationRequest
	ListApplicationsResponse
	AppVersion
	CreateAppVersionRequest
	CreateAppVersionResponse
	ReadAppVersionRequest
	ReadAppVersionResponse
	UpdateAppVersionRequest
	UpdateAppVersionResponse
	DeleteAppVersionRequest
	DeleteAppVersionResponse
	ListAppVersionRequest
	ListAppVersionsResponse
	ApplicationInstance
	CreateApplicationInstanceRequest
	CreateApplicationInstanceResponse
	ReadApplicationInstanceRequest
	ReadApplicationInstanceResponse
	UpdateApplicationInstanceRequest
	UpdateApplicationInstanceResponse
	DeleteApplicationInstanceRequest
	DeleteApplicationInstanceResponse
	ListApplicationInstanceRequest
	ListApplicationInstancesResponse
	Vault
	CreateVaultRequest
	CreateVaultResponse
	ReadVaultRequest
	ReadVaultResponse
	UpdateVaultRequest
	UpdateVaultResponse
	DeleteVaultRequest
	DeleteVaultResponse
	ListVaultRequest
	ListVaultsResponse
	Secret
	CreateSecretRequest
	CreateSecretResponse
	ReadSecretRequest
	ReadSecretResponse
	UpdateSecretRequest
	UpdateSecretResponse
	DeleteSecretRequest
	DeleteSecretResponse
	ListSecretRequest
	ListSecretsResponse
	Artifact
	CreateArtifactRequest
	CreateArtifactResponse
	ReadArtifactRequest
	ReadArtifactResponse
	UpdateArtifactRequest
	UpdateArtifactResponse
	DeleteArtifactRequest
	DeleteArtifactResponse
	ListArtifactRequest
	ListArtifactsResponse
	KubeCluster
	CreateKubeClusterRequest
	CreateKubeClusterResponse
	ReadKubeClusterRequest
	ReadKubeClusterResponse
	UpdateKubeClusterRequest
	UpdateKubeClusterResponse
	DeleteKubeClusterRequest
	DeleteKubeClusterResponse
	ListKubeClusterRequest
	ListKubeClustersResponse
	Deployment
	CreateDeploymentRequest
	CreateDeploymentResponse
	ReadDeploymentRequest
	ReadDeploymentResponse
	UpdateDeploymentRequest
	UpdateDeploymentResponse
	DeleteDeploymentRequest
	DeleteDeploymentResponse
	ListDeploymentRequest
	ListDeploymentsResponse
*/
package pb

import context "context"
import fmt "fmt"
import strings "strings"

import auth1 "github.com/infobloxopen/atlas-app-toolkit/auth"
import errors1 "github.com/infobloxopen/protoc-gen-gorm/errors"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
import postgres1 "github.com/jinzhu/gorm/dialects/postgres"
import query1 "github.com/infobloxopen/atlas-app-toolkit/query"
import resource1 "github.com/infobloxopen/atlas-app-toolkit/gorm/resource"
import types1 "github.com/infobloxopen/protoc-gen-gorm/types"

import math "math"
import _ "github.com/golang/protobuf/ptypes/empty"
import _ "google.golang.org/genproto/protobuf/field_mask"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/lyft/protoc-gen-validate/validate"
import _ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
import _ "github.com/infobloxopen/atlas-app-toolkit/query"
import _ "github.com/infobloxopen/atlas-app-toolkit/rpc/resource"
import _ "github.com/infobloxopen/protoc-gen-atlas-query-validate/options"
import _ "github.com/infobloxopen/protoc-gen-atlas-validate/options"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type CloudProviderORM struct {
	Account     string
	AccountID   string
	Description string
	Id          string `gorm:"type:UUID;primary_key"`
	Name        string
	Provider    int32
	Regions     []*RegionORM `gorm:"foreignkey:CloudProviderId;association_foreignkey:Id"`
}

// TableName overrides the default tablename generated by GORM
func (CloudProviderORM) TableName() string {
	return "cloud_providers"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CloudProvider) ToORM(ctx context.Context) (CloudProviderORM, error) {
	to := CloudProviderORM{}
	var err error
	if prehook, ok := interface{}(m).(CloudProviderWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&CloudProvider{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Provider = int32(m.Provider)
	to.Account = m.Account
	for _, v := range m.Regions {
		if v != nil {
			if tempRegions, cErr := v.ToORM(ctx); cErr == nil {
				to.Regions = append(to.Regions, &tempRegions)
			} else {
				return to, cErr
			}
		} else {
			to.Regions = append(to.Regions, nil)
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(CloudProviderWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CloudProviderORM) ToPB(ctx context.Context) (CloudProvider, error) {
	to := CloudProvider{}
	var err error
	if prehook, ok := interface{}(m).(CloudProviderWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&CloudProvider{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Provider = Provider(m.Provider)
	to.Account = m.Account
	for _, v := range m.Regions {
		if v != nil {
			if tempRegions, cErr := v.ToPB(ctx); cErr == nil {
				to.Regions = append(to.Regions, &tempRegions)
			} else {
				return to, cErr
			}
		} else {
			to.Regions = append(to.Regions, nil)
		}
	}
	if posthook, ok := interface{}(m).(CloudProviderWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CloudProvider the arg will be the target, the caller the one being converted from

// CloudProviderBeforeToORM called before default ToORM code
type CloudProviderWithBeforeToORM interface {
	BeforeToORM(context.Context, *CloudProviderORM) error
}

// CloudProviderAfterToORM called after default ToORM code
type CloudProviderWithAfterToORM interface {
	AfterToORM(context.Context, *CloudProviderORM) error
}

// CloudProviderBeforeToPB called before default ToPB code
type CloudProviderWithBeforeToPB interface {
	BeforeToPB(context.Context, *CloudProvider) error
}

// CloudProviderAfterToPB called after default ToPB code
type CloudProviderWithAfterToPB interface {
	AfterToPB(context.Context, *CloudProvider) error
}

type RegionORM struct {
	AccountID       string
	CloudProviderId *string `gorm:"type:UUID"`
	Description     string
	Id              string `gorm:"type:UUID;primary_key"`
	Name            string
	Networks        []*NetworkORM `gorm:"foreignkey:RegionId;association_foreignkey:Id"`
}

// TableName overrides the default tablename generated by GORM
func (RegionORM) TableName() string {
	return "regions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Region) ToORM(ctx context.Context) (RegionORM, error) {
	to := RegionORM{}
	var err error
	if prehook, ok := interface{}(m).(RegionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&Region{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	to.Name = m.Name
	to.Description = m.Description
	for _, v := range m.Networks {
		if v != nil {
			if tempNetworks, cErr := v.ToORM(ctx); cErr == nil {
				to.Networks = append(to.Networks, &tempNetworks)
			} else {
				return to, cErr
			}
		} else {
			to.Networks = append(to.Networks, nil)
		}
	}
	if m.CloudProviderId != nil {
		if v, err := resource1.Decode(&CloudProvider{}, m.CloudProviderId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.CloudProviderId = &vv
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(RegionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *RegionORM) ToPB(ctx context.Context) (Region, error) {
	to := Region{}
	var err error
	if prehook, ok := interface{}(m).(RegionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Region{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	for _, v := range m.Networks {
		if v != nil {
			if tempNetworks, cErr := v.ToPB(ctx); cErr == nil {
				to.Networks = append(to.Networks, &tempNetworks)
			} else {
				return to, cErr
			}
		} else {
			to.Networks = append(to.Networks, nil)
		}
	}
	if m.CloudProviderId != nil {
		if v, err := resource1.Encode(&CloudProvider{}, *m.CloudProviderId); err != nil {
			return to, err
		} else {
			to.CloudProviderId = v
		}
	}
	if posthook, ok := interface{}(m).(RegionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Region the arg will be the target, the caller the one being converted from

// RegionBeforeToORM called before default ToORM code
type RegionWithBeforeToORM interface {
	BeforeToORM(context.Context, *RegionORM) error
}

// RegionAfterToORM called after default ToORM code
type RegionWithAfterToORM interface {
	AfterToORM(context.Context, *RegionORM) error
}

// RegionBeforeToPB called before default ToPB code
type RegionWithBeforeToPB interface {
	BeforeToPB(context.Context, *Region) error
}

// RegionAfterToPB called after default ToPB code
type RegionWithAfterToPB interface {
	AfterToPB(context.Context, *Region) error
}

type NetworkORM struct {
	AccountID   string
	Description string
	Id          string `gorm:"type:UUID;primary_key"`
	Name        string
	RegionId    *string `gorm:"type:UUID"`
}

// TableName overrides the default tablename generated by GORM
func (NetworkORM) TableName() string {
	return "networks"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Network) ToORM(ctx context.Context) (NetworkORM, error) {
	to := NetworkORM{}
	var err error
	if prehook, ok := interface{}(m).(NetworkWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&Network{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	to.Name = m.Name
	to.Description = m.Description
	if m.RegionId != nil {
		if v, err := resource1.Decode(&Region{}, m.RegionId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.RegionId = &vv
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(NetworkWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NetworkORM) ToPB(ctx context.Context) (Network, error) {
	to := Network{}
	var err error
	if prehook, ok := interface{}(m).(NetworkWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Network{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	if m.RegionId != nil {
		if v, err := resource1.Encode(&Region{}, *m.RegionId); err != nil {
			return to, err
		} else {
			to.RegionId = v
		}
	}
	if posthook, ok := interface{}(m).(NetworkWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Network the arg will be the target, the caller the one being converted from

// NetworkBeforeToORM called before default ToORM code
type NetworkWithBeforeToORM interface {
	BeforeToORM(context.Context, *NetworkORM) error
}

// NetworkAfterToORM called after default ToORM code
type NetworkWithAfterToORM interface {
	AfterToORM(context.Context, *NetworkORM) error
}

// NetworkBeforeToPB called before default ToPB code
type NetworkWithBeforeToPB interface {
	BeforeToPB(context.Context, *Network) error
}

// NetworkAfterToPB called after default ToPB code
type NetworkWithAfterToPB interface {
	AfterToPB(context.Context, *Network) error
}

type LifecycleORM struct {
	AccountID    string
	AppConfig    []*AppConfigORM  `gorm:"foreignkey:LifecycleId;association_foreignkey:Id"`
	AppVersion   []*AppVersionORM `gorm:"foreignkey:LifecycleId;association_foreignkey:Id"`
	ConfigYaml   string
	Description  string
	Environments []*EnvironmentORM `gorm:"foreignkey:LifecycleId;association_foreignkey:Id"`
	Id           string            `gorm:"type:UUID;primary_key"`
	LifecycleId  *string           `gorm:"type:UUID"`
	Lifecycles   []*LifecycleORM   `gorm:"foreignkey:LifecycleId;association_foreignkey:Id"`
	Name         string
}

// TableName overrides the default tablename generated by GORM
func (LifecycleORM) TableName() string {
	return "lifecycles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Lifecycle) ToORM(ctx context.Context) (LifecycleORM, error) {
	to := LifecycleORM{}
	var err error
	if prehook, ok := interface{}(m).(LifecycleWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&Lifecycle{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	to.Name = m.Name
	to.Description = m.Description
	to.ConfigYaml = m.ConfigYaml
	for _, v := range m.Environments {
		if v != nil {
			if tempEnvironments, cErr := v.ToORM(ctx); cErr == nil {
				to.Environments = append(to.Environments, &tempEnvironments)
			} else {
				return to, cErr
			}
		} else {
			to.Environments = append(to.Environments, nil)
		}
	}
	for _, v := range m.Lifecycles {
		if v != nil {
			if tempLifecycles, cErr := v.ToORM(ctx); cErr == nil {
				to.Lifecycles = append(to.Lifecycles, &tempLifecycles)
			} else {
				return to, cErr
			}
		} else {
			to.Lifecycles = append(to.Lifecycles, nil)
		}
	}
	for _, v := range m.AppConfig {
		if v != nil {
			if tempAppConfig, cErr := v.ToORM(ctx); cErr == nil {
				to.AppConfig = append(to.AppConfig, &tempAppConfig)
			} else {
				return to, cErr
			}
		} else {
			to.AppConfig = append(to.AppConfig, nil)
		}
	}
	for _, v := range m.AppVersion {
		if v != nil {
			if tempAppVersion, cErr := v.ToORM(ctx); cErr == nil {
				to.AppVersion = append(to.AppVersion, &tempAppVersion)
			} else {
				return to, cErr
			}
		} else {
			to.AppVersion = append(to.AppVersion, nil)
		}
	}
	if m.LifecycleId != nil {
		if v, err := resource1.Decode(&Lifecycle{}, m.LifecycleId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.LifecycleId = &vv
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(LifecycleWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *LifecycleORM) ToPB(ctx context.Context) (Lifecycle, error) {
	to := Lifecycle{}
	var err error
	if prehook, ok := interface{}(m).(LifecycleWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Lifecycle{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.ConfigYaml = m.ConfigYaml
	for _, v := range m.Environments {
		if v != nil {
			if tempEnvironments, cErr := v.ToPB(ctx); cErr == nil {
				to.Environments = append(to.Environments, &tempEnvironments)
			} else {
				return to, cErr
			}
		} else {
			to.Environments = append(to.Environments, nil)
		}
	}
	for _, v := range m.Lifecycles {
		if v != nil {
			if tempLifecycles, cErr := v.ToPB(ctx); cErr == nil {
				to.Lifecycles = append(to.Lifecycles, &tempLifecycles)
			} else {
				return to, cErr
			}
		} else {
			to.Lifecycles = append(to.Lifecycles, nil)
		}
	}
	for _, v := range m.AppConfig {
		if v != nil {
			if tempAppConfig, cErr := v.ToPB(ctx); cErr == nil {
				to.AppConfig = append(to.AppConfig, &tempAppConfig)
			} else {
				return to, cErr
			}
		} else {
			to.AppConfig = append(to.AppConfig, nil)
		}
	}
	for _, v := range m.AppVersion {
		if v != nil {
			if tempAppVersion, cErr := v.ToPB(ctx); cErr == nil {
				to.AppVersion = append(to.AppVersion, &tempAppVersion)
			} else {
				return to, cErr
			}
		} else {
			to.AppVersion = append(to.AppVersion, nil)
		}
	}
	if m.LifecycleId != nil {
		if v, err := resource1.Encode(&Lifecycle{}, *m.LifecycleId); err != nil {
			return to, err
		} else {
			to.LifecycleId = v
		}
	}
	if posthook, ok := interface{}(m).(LifecycleWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Lifecycle the arg will be the target, the caller the one being converted from

// LifecycleBeforeToORM called before default ToORM code
type LifecycleWithBeforeToORM interface {
	BeforeToORM(context.Context, *LifecycleORM) error
}

// LifecycleAfterToORM called after default ToORM code
type LifecycleWithAfterToORM interface {
	AfterToORM(context.Context, *LifecycleORM) error
}

// LifecycleBeforeToPB called before default ToPB code
type LifecycleWithBeforeToPB interface {
	BeforeToPB(context.Context, *Lifecycle) error
}

// LifecycleAfterToPB called after default ToPB code
type LifecycleWithAfterToPB interface {
	AfterToPB(context.Context, *Lifecycle) error
}

type ChartVersionORM struct {
	AccountID     string
	ApplicationId *string          `gorm:"type:UUID"`
	ChartStore    *postgres1.Jsonb `gorm:"type:jsonb"`
	Description   string
	Id            string `gorm:"type:UUID;primary_key"`
	Name          string
	Repo          string
	Version       string
}

// TableName overrides the default tablename generated by GORM
func (ChartVersionORM) TableName() string {
	return "chart_versions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ChartVersion) ToORM(ctx context.Context) (ChartVersionORM, error) {
	to := ChartVersionORM{}
	var err error
	if prehook, ok := interface{}(m).(ChartVersionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&ChartVersion{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Repo = m.Repo
	to.Version = m.Version
	if m.ChartStore != nil {
		to.ChartStore = &postgres1.Jsonb{[]byte(m.ChartStore.Value)}
	}
	if m.ApplicationId != nil {
		if v, err := resource1.Decode(&Application{}, m.ApplicationId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.ApplicationId = &vv
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ChartVersionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ChartVersionORM) ToPB(ctx context.Context) (ChartVersion, error) {
	to := ChartVersion{}
	var err error
	if prehook, ok := interface{}(m).(ChartVersionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ChartVersion{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Repo = m.Repo
	to.Version = m.Version
	if m.ChartStore != nil {
		to.ChartStore = &types1.JSONValue{Value: string(m.ChartStore.RawMessage)}
	}
	if m.ApplicationId != nil {
		if v, err := resource1.Encode(&Application{}, *m.ApplicationId); err != nil {
			return to, err
		} else {
			to.ApplicationId = v
		}
	}
	if posthook, ok := interface{}(m).(ChartVersionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ChartVersion the arg will be the target, the caller the one being converted from

// ChartVersionBeforeToORM called before default ToORM code
type ChartVersionWithBeforeToORM interface {
	BeforeToORM(context.Context, *ChartVersionORM) error
}

// ChartVersionAfterToORM called after default ToORM code
type ChartVersionWithAfterToORM interface {
	AfterToORM(context.Context, *ChartVersionORM) error
}

// ChartVersionBeforeToPB called before default ToPB code
type ChartVersionWithBeforeToPB interface {
	BeforeToPB(context.Context, *ChartVersion) error
}

// ChartVersionAfterToPB called after default ToPB code
type ChartVersionWithAfterToPB interface {
	AfterToPB(context.Context, *ChartVersion) error
}

type AppConfigORM struct {
	AccountID     string
	ApplicationId *string `gorm:"type:UUID"`
	ConfigYaml    string
	Description   string
	EnvironmentId *string `gorm:"type:UUID"`
	Id            string  `gorm:"type:UUID;primary_key"`
	LifecycleId   *string `gorm:"type:UUID"`
	Name          string
}

// TableName overrides the default tablename generated by GORM
func (AppConfigORM) TableName() string {
	return "app_configs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AppConfig) ToORM(ctx context.Context) (AppConfigORM, error) {
	to := AppConfigORM{}
	var err error
	if prehook, ok := interface{}(m).(AppConfigWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&AppConfig{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	to.Name = m.Name
	to.Description = m.Description
	to.ConfigYaml = m.ConfigYaml
	if m.ApplicationId != nil {
		if v, err := resource1.Decode(&Application{}, m.ApplicationId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.ApplicationId = &vv
		}
	}
	if m.LifecycleId != nil {
		if v, err := resource1.Decode(&Lifecycle{}, m.LifecycleId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.LifecycleId = &vv
		}
	}
	if m.EnvironmentId != nil {
		if v, err := resource1.Decode(&Environment{}, m.EnvironmentId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.EnvironmentId = &vv
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(AppConfigWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AppConfigORM) ToPB(ctx context.Context) (AppConfig, error) {
	to := AppConfig{}
	var err error
	if prehook, ok := interface{}(m).(AppConfigWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&AppConfig{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.ConfigYaml = m.ConfigYaml
	if m.ApplicationId != nil {
		if v, err := resource1.Encode(&Application{}, *m.ApplicationId); err != nil {
			return to, err
		} else {
			to.ApplicationId = v
		}
	}
	if m.LifecycleId != nil {
		if v, err := resource1.Encode(&Lifecycle{}, *m.LifecycleId); err != nil {
			return to, err
		} else {
			to.LifecycleId = v
		}
	}
	if m.EnvironmentId != nil {
		if v, err := resource1.Encode(&Environment{}, *m.EnvironmentId); err != nil {
			return to, err
		} else {
			to.EnvironmentId = v
		}
	}
	if posthook, ok := interface{}(m).(AppConfigWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AppConfig the arg will be the target, the caller the one being converted from

// AppConfigBeforeToORM called before default ToORM code
type AppConfigWithBeforeToORM interface {
	BeforeToORM(context.Context, *AppConfigORM) error
}

// AppConfigAfterToORM called after default ToORM code
type AppConfigWithAfterToORM interface {
	AfterToORM(context.Context, *AppConfigORM) error
}

// AppConfigBeforeToPB called before default ToPB code
type AppConfigWithBeforeToPB interface {
	BeforeToPB(context.Context, *AppConfig) error
}

// AppConfigAfterToPB called after default ToPB code
type AppConfigWithAfterToPB interface {
	AfterToPB(context.Context, *AppConfig) error
}

type EnvironmentORM struct {
	AccountID            string
	AppConfig            []*AppConfigORM           `gorm:"foreignkey:EnvironmentId;association_foreignkey:Id"`
	AppVersion           []*AppVersionORM          `gorm:"foreignkey:EnvironmentId;association_foreignkey:Id"`
	ApplicationInstances []*ApplicationInstanceORM `gorm:"foreignkey:EnvironmentId;association_foreignkey:Id"`
	ConfigYaml           string
	Description          string
	Id                   string  `gorm:"type:UUID;primary_key"`
	LifecycleId          *string `gorm:"type:UUID"`
	Name                 string
}

// TableName overrides the default tablename generated by GORM
func (EnvironmentORM) TableName() string {
	return "environments"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Environment) ToORM(ctx context.Context) (EnvironmentORM, error) {
	to := EnvironmentORM{}
	var err error
	if prehook, ok := interface{}(m).(EnvironmentWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&Environment{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	to.Name = m.Name
	to.Description = m.Description
	to.ConfigYaml = m.ConfigYaml
	for _, v := range m.ApplicationInstances {
		if v != nil {
			if tempApplicationInstances, cErr := v.ToORM(ctx); cErr == nil {
				to.ApplicationInstances = append(to.ApplicationInstances, &tempApplicationInstances)
			} else {
				return to, cErr
			}
		} else {
			to.ApplicationInstances = append(to.ApplicationInstances, nil)
		}
	}
	for _, v := range m.AppConfig {
		if v != nil {
			if tempAppConfig, cErr := v.ToORM(ctx); cErr == nil {
				to.AppConfig = append(to.AppConfig, &tempAppConfig)
			} else {
				return to, cErr
			}
		} else {
			to.AppConfig = append(to.AppConfig, nil)
		}
	}
	for _, v := range m.AppVersion {
		if v != nil {
			if tempAppVersion, cErr := v.ToORM(ctx); cErr == nil {
				to.AppVersion = append(to.AppVersion, &tempAppVersion)
			} else {
				return to, cErr
			}
		} else {
			to.AppVersion = append(to.AppVersion, nil)
		}
	}
	if m.LifecycleId != nil {
		if v, err := resource1.Decode(&Lifecycle{}, m.LifecycleId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.LifecycleId = &vv
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(EnvironmentWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EnvironmentORM) ToPB(ctx context.Context) (Environment, error) {
	to := Environment{}
	var err error
	if prehook, ok := interface{}(m).(EnvironmentWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Environment{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.ConfigYaml = m.ConfigYaml
	for _, v := range m.ApplicationInstances {
		if v != nil {
			if tempApplicationInstances, cErr := v.ToPB(ctx); cErr == nil {
				to.ApplicationInstances = append(to.ApplicationInstances, &tempApplicationInstances)
			} else {
				return to, cErr
			}
		} else {
			to.ApplicationInstances = append(to.ApplicationInstances, nil)
		}
	}
	for _, v := range m.AppConfig {
		if v != nil {
			if tempAppConfig, cErr := v.ToPB(ctx); cErr == nil {
				to.AppConfig = append(to.AppConfig, &tempAppConfig)
			} else {
				return to, cErr
			}
		} else {
			to.AppConfig = append(to.AppConfig, nil)
		}
	}
	for _, v := range m.AppVersion {
		if v != nil {
			if tempAppVersion, cErr := v.ToPB(ctx); cErr == nil {
				to.AppVersion = append(to.AppVersion, &tempAppVersion)
			} else {
				return to, cErr
			}
		} else {
			to.AppVersion = append(to.AppVersion, nil)
		}
	}
	if m.LifecycleId != nil {
		if v, err := resource1.Encode(&Lifecycle{}, *m.LifecycleId); err != nil {
			return to, err
		} else {
			to.LifecycleId = v
		}
	}
	if posthook, ok := interface{}(m).(EnvironmentWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Environment the arg will be the target, the caller the one being converted from

// EnvironmentBeforeToORM called before default ToORM code
type EnvironmentWithBeforeToORM interface {
	BeforeToORM(context.Context, *EnvironmentORM) error
}

// EnvironmentAfterToORM called after default ToORM code
type EnvironmentWithAfterToORM interface {
	AfterToORM(context.Context, *EnvironmentORM) error
}

// EnvironmentBeforeToPB called before default ToPB code
type EnvironmentWithBeforeToPB interface {
	BeforeToPB(context.Context, *Environment) error
}

// EnvironmentAfterToPB called after default ToPB code
type EnvironmentWithAfterToPB interface {
	AfterToPB(context.Context, *Environment) error
}

type ApplicationORM struct {
	AccountID   string
	Chart       string
	ConfigYaml  string
	Description string
	Id          string `gorm:"type:UUID;primary_key"`
	Name        string
	Repo        string
	TicketLink  string
}

// TableName overrides the default tablename generated by GORM
func (ApplicationORM) TableName() string {
	return "applications"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Application) ToORM(ctx context.Context) (ApplicationORM, error) {
	to := ApplicationORM{}
	var err error
	if prehook, ok := interface{}(m).(ApplicationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&Application{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Chart = m.Chart
	to.Repo = m.Repo
	to.TicketLink = m.TicketLink
	to.ConfigYaml = m.ConfigYaml
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ApplicationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ApplicationORM) ToPB(ctx context.Context) (Application, error) {
	to := Application{}
	var err error
	if prehook, ok := interface{}(m).(ApplicationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Application{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Chart = m.Chart
	to.Repo = m.Repo
	to.TicketLink = m.TicketLink
	to.ConfigYaml = m.ConfigYaml
	if posthook, ok := interface{}(m).(ApplicationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Application the arg will be the target, the caller the one being converted from

// ApplicationBeforeToORM called before default ToORM code
type ApplicationWithBeforeToORM interface {
	BeforeToORM(context.Context, *ApplicationORM) error
}

// ApplicationAfterToORM called after default ToORM code
type ApplicationWithAfterToORM interface {
	AfterToORM(context.Context, *ApplicationORM) error
}

// ApplicationBeforeToPB called before default ToPB code
type ApplicationWithBeforeToPB interface {
	BeforeToPB(context.Context, *Application) error
}

// ApplicationAfterToPB called after default ToPB code
type ApplicationWithAfterToPB interface {
	AfterToPB(context.Context, *Application) error
}

type AppVersionORM struct {
	AccountID      string
	ApplicationId  *string          `gorm:"type:UUID"`
	ChartVersion   *ChartVersionORM `gorm:"foreignkey:ChartVersionId;association_foreignkey:Id"`
	ChartVersionId *string          `gorm:"type:UUID"`
	Description    string
	EnvironmentId  *string `gorm:"type:UUID"`
	Id             string  `gorm:"type:UUID;primary_key"`
	LifecycleId    *string `gorm:"type:UUID"`
	Name           string
}

// TableName overrides the default tablename generated by GORM
func (AppVersionORM) TableName() string {
	return "app_versions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AppVersion) ToORM(ctx context.Context) (AppVersionORM, error) {
	to := AppVersionORM{}
	var err error
	if prehook, ok := interface{}(m).(AppVersionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&AppVersion{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	to.Name = m.Name
	to.Description = m.Description
	if m.ChartVersion != nil {
		tempChartVersion, err := m.ChartVersion.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.ChartVersion = &tempChartVersion
	}
	if m.ChartVersionId != nil {
		if v, err := resource1.Decode(&ChartVersion{}, m.ChartVersionId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.ChartVersionId = &vv
		}
	}
	if m.ApplicationId != nil {
		if v, err := resource1.Decode(&Application{}, m.ApplicationId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.ApplicationId = &vv
		}
	}
	if m.LifecycleId != nil {
		if v, err := resource1.Decode(&Lifecycle{}, m.LifecycleId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.LifecycleId = &vv
		}
	}
	if m.EnvironmentId != nil {
		if v, err := resource1.Decode(&Environment{}, m.EnvironmentId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.EnvironmentId = &vv
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(AppVersionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AppVersionORM) ToPB(ctx context.Context) (AppVersion, error) {
	to := AppVersion{}
	var err error
	if prehook, ok := interface{}(m).(AppVersionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&AppVersion{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	if m.ChartVersion != nil {
		tempChartVersion, err := m.ChartVersion.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.ChartVersion = &tempChartVersion
	}
	if m.ChartVersionId != nil {
		if v, err := resource1.Encode(&ChartVersion{}, *m.ChartVersionId); err != nil {
			return to, err
		} else {
			to.ChartVersionId = v
		}
	}
	if m.ApplicationId != nil {
		if v, err := resource1.Encode(&Application{}, *m.ApplicationId); err != nil {
			return to, err
		} else {
			to.ApplicationId = v
		}
	}
	if m.LifecycleId != nil {
		if v, err := resource1.Encode(&Lifecycle{}, *m.LifecycleId); err != nil {
			return to, err
		} else {
			to.LifecycleId = v
		}
	}
	if m.EnvironmentId != nil {
		if v, err := resource1.Encode(&Environment{}, *m.EnvironmentId); err != nil {
			return to, err
		} else {
			to.EnvironmentId = v
		}
	}
	if posthook, ok := interface{}(m).(AppVersionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AppVersion the arg will be the target, the caller the one being converted from

// AppVersionBeforeToORM called before default ToORM code
type AppVersionWithBeforeToORM interface {
	BeforeToORM(context.Context, *AppVersionORM) error
}

// AppVersionAfterToORM called after default ToORM code
type AppVersionWithAfterToORM interface {
	AfterToORM(context.Context, *AppVersionORM) error
}

// AppVersionBeforeToPB called before default ToPB code
type AppVersionWithBeforeToPB interface {
	BeforeToPB(context.Context, *AppVersion) error
}

// AppVersionAfterToPB called after default ToPB code
type AppVersionWithAfterToPB interface {
	AfterToPB(context.Context, *AppVersion) error
}

type ApplicationInstanceORM struct {
	AccountID      string
	ApplicationId  *string          `gorm:"type:UUID"`
	ChartVersion   *ChartVersionORM `gorm:"foreignkey:ChartVersionId;association_foreignkey:Id;preload:false"`
	ChartVersionId *string          `gorm:"type:UUID"`
	ConfigYaml     string
	Deployment     *DeploymentORM `gorm:"foreignkey:ApplicationInstanceId;association_foreignkey:Id"`
	Description    string
	Enable         bool
	EnvironmentId  *string `gorm:"type:UUID"`
	Id             string  `gorm:"type:UUID;primary_key"`
	Name           string
}

// TableName overrides the default tablename generated by GORM
func (ApplicationInstanceORM) TableName() string {
	return "application_instances"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ApplicationInstance) ToORM(ctx context.Context) (ApplicationInstanceORM, error) {
	to := ApplicationInstanceORM{}
	var err error
	if prehook, ok := interface{}(m).(ApplicationInstanceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&ApplicationInstance{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Enable = m.Enable
	if m.Deployment != nil {
		tempDeployment, err := m.Deployment.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Deployment = &tempDeployment
	}
	to.ConfigYaml = m.ConfigYaml
	if m.ChartVersion != nil {
		tempChartVersion, err := m.ChartVersion.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.ChartVersion = &tempChartVersion
	}
	if m.ChartVersionId != nil {
		if v, err := resource1.Decode(&ChartVersion{}, m.ChartVersionId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.ChartVersionId = &vv
		}
	}
	if m.EnvironmentId != nil {
		if v, err := resource1.Decode(&Environment{}, m.EnvironmentId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.EnvironmentId = &vv
		}
	}
	if m.ApplicationId != nil {
		if v, err := resource1.Decode(&Application{}, m.ApplicationId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.ApplicationId = &vv
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ApplicationInstanceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ApplicationInstanceORM) ToPB(ctx context.Context) (ApplicationInstance, error) {
	to := ApplicationInstance{}
	var err error
	if prehook, ok := interface{}(m).(ApplicationInstanceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ApplicationInstance{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Enable = m.Enable
	if m.Deployment != nil {
		tempDeployment, err := m.Deployment.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Deployment = &tempDeployment
	}
	to.ConfigYaml = m.ConfigYaml
	if m.ChartVersion != nil {
		tempChartVersion, err := m.ChartVersion.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.ChartVersion = &tempChartVersion
	}
	if m.ChartVersionId != nil {
		if v, err := resource1.Encode(&ChartVersion{}, *m.ChartVersionId); err != nil {
			return to, err
		} else {
			to.ChartVersionId = v
		}
	}
	if m.EnvironmentId != nil {
		if v, err := resource1.Encode(&Environment{}, *m.EnvironmentId); err != nil {
			return to, err
		} else {
			to.EnvironmentId = v
		}
	}
	if m.ApplicationId != nil {
		if v, err := resource1.Encode(&Application{}, *m.ApplicationId); err != nil {
			return to, err
		} else {
			to.ApplicationId = v
		}
	}
	if posthook, ok := interface{}(m).(ApplicationInstanceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ApplicationInstance the arg will be the target, the caller the one being converted from

// ApplicationInstanceBeforeToORM called before default ToORM code
type ApplicationInstanceWithBeforeToORM interface {
	BeforeToORM(context.Context, *ApplicationInstanceORM) error
}

// ApplicationInstanceAfterToORM called after default ToORM code
type ApplicationInstanceWithAfterToORM interface {
	AfterToORM(context.Context, *ApplicationInstanceORM) error
}

// ApplicationInstanceBeforeToPB called before default ToPB code
type ApplicationInstanceWithBeforeToPB interface {
	BeforeToPB(context.Context, *ApplicationInstance) error
}

// ApplicationInstanceAfterToPB called after default ToPB code
type ApplicationInstanceWithAfterToPB interface {
	AfterToPB(context.Context, *ApplicationInstance) error
}

type VaultORM struct {
	AccountID   string
	Description string
	Id          string `gorm:"type:UUID;primary_key"`
	Name        string
	Secrets     []*SecretORM `gorm:"foreignkey:VaultId;association_foreignkey:Id"`
}

// TableName overrides the default tablename generated by GORM
func (VaultORM) TableName() string {
	return "vaults"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Vault) ToORM(ctx context.Context) (VaultORM, error) {
	to := VaultORM{}
	var err error
	if prehook, ok := interface{}(m).(VaultWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&Vault{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	to.Name = m.Name
	to.Description = m.Description
	for _, v := range m.Secrets {
		if v != nil {
			if tempSecrets, cErr := v.ToORM(ctx); cErr == nil {
				to.Secrets = append(to.Secrets, &tempSecrets)
			} else {
				return to, cErr
			}
		} else {
			to.Secrets = append(to.Secrets, nil)
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(VaultWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *VaultORM) ToPB(ctx context.Context) (Vault, error) {
	to := Vault{}
	var err error
	if prehook, ok := interface{}(m).(VaultWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Vault{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	for _, v := range m.Secrets {
		if v != nil {
			if tempSecrets, cErr := v.ToPB(ctx); cErr == nil {
				to.Secrets = append(to.Secrets, &tempSecrets)
			} else {
				return to, cErr
			}
		} else {
			to.Secrets = append(to.Secrets, nil)
		}
	}
	if posthook, ok := interface{}(m).(VaultWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Vault the arg will be the target, the caller the one being converted from

// VaultBeforeToORM called before default ToORM code
type VaultWithBeforeToORM interface {
	BeforeToORM(context.Context, *VaultORM) error
}

// VaultAfterToORM called after default ToORM code
type VaultWithAfterToORM interface {
	AfterToORM(context.Context, *VaultORM) error
}

// VaultBeforeToPB called before default ToPB code
type VaultWithBeforeToPB interface {
	BeforeToPB(context.Context, *Vault) error
}

// VaultAfterToPB called after default ToPB code
type VaultWithAfterToPB interface {
	AfterToPB(context.Context, *Vault) error
}

type SecretORM struct {
	AccountID   string
	Description string
	Id          string `gorm:"type:UUID;primary_key"`
	Key         string
	Name        string
	Path        string
	Type        string
	VaultId     *string `gorm:"type:UUID"`
}

// TableName overrides the default tablename generated by GORM
func (SecretORM) TableName() string {
	return "secrets"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Secret) ToORM(ctx context.Context) (SecretORM, error) {
	to := SecretORM{}
	var err error
	if prehook, ok := interface{}(m).(SecretWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&Secret{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Path = m.Path
	to.Type = m.Type
	to.Key = m.Key
	if m.VaultId != nil {
		if v, err := resource1.Decode(&Vault{}, m.VaultId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.VaultId = &vv
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(SecretWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SecretORM) ToPB(ctx context.Context) (Secret, error) {
	to := Secret{}
	var err error
	if prehook, ok := interface{}(m).(SecretWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Secret{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Path = m.Path
	to.Type = m.Type
	to.Key = m.Key
	if m.VaultId != nil {
		if v, err := resource1.Encode(&Vault{}, *m.VaultId); err != nil {
			return to, err
		} else {
			to.VaultId = v
		}
	}
	if posthook, ok := interface{}(m).(SecretWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Secret the arg will be the target, the caller the one being converted from

// SecretBeforeToORM called before default ToORM code
type SecretWithBeforeToORM interface {
	BeforeToORM(context.Context, *SecretORM) error
}

// SecretAfterToORM called after default ToORM code
type SecretWithAfterToORM interface {
	AfterToORM(context.Context, *SecretORM) error
}

// SecretBeforeToPB called before default ToPB code
type SecretWithBeforeToPB interface {
	BeforeToPB(context.Context, *Secret) error
}

// SecretAfterToPB called after default ToPB code
type SecretWithAfterToPB interface {
	AfterToPB(context.Context, *Secret) error
}

type ArtifactORM struct {
	AccountID      string
	ChartVersionId *string `gorm:"type:UUID"`
	Commit         string
	Description    string
	Id             string `gorm:"type:UUID;primary_key"`
	Name           string
	Repo           string
}

// TableName overrides the default tablename generated by GORM
func (ArtifactORM) TableName() string {
	return "artifacts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Artifact) ToORM(ctx context.Context) (ArtifactORM, error) {
	to := ArtifactORM{}
	var err error
	if prehook, ok := interface{}(m).(ArtifactWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&Artifact{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Repo = m.Repo
	to.Commit = m.Commit
	if m.ChartVersionId != nil {
		if v, err := resource1.Decode(&ChartVersion{}, m.ChartVersionId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.ChartVersionId = &vv
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ArtifactWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ArtifactORM) ToPB(ctx context.Context) (Artifact, error) {
	to := Artifact{}
	var err error
	if prehook, ok := interface{}(m).(ArtifactWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Artifact{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Repo = m.Repo
	to.Commit = m.Commit
	if m.ChartVersionId != nil {
		if v, err := resource1.Encode(&ChartVersion{}, *m.ChartVersionId); err != nil {
			return to, err
		} else {
			to.ChartVersionId = v
		}
	}
	if posthook, ok := interface{}(m).(ArtifactWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Artifact the arg will be the target, the caller the one being converted from

// ArtifactBeforeToORM called before default ToORM code
type ArtifactWithBeforeToORM interface {
	BeforeToORM(context.Context, *ArtifactORM) error
}

// ArtifactAfterToORM called after default ToORM code
type ArtifactWithAfterToORM interface {
	AfterToORM(context.Context, *ArtifactORM) error
}

// ArtifactBeforeToPB called before default ToPB code
type ArtifactWithBeforeToPB interface {
	BeforeToPB(context.Context, *Artifact) error
}

// ArtifactAfterToPB called after default ToPB code
type ArtifactWithAfterToPB interface {
	AfterToPB(context.Context, *Artifact) error
}

type KubeClusterORM struct {
	AccountID   string
	Description string
	Id          string `gorm:"type:UUID;primary_key"`
	Name        string
	NetworkId   *string `gorm:"type:UUID"`
}

// TableName overrides the default tablename generated by GORM
func (KubeClusterORM) TableName() string {
	return "kube_clusters"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *KubeCluster) ToORM(ctx context.Context) (KubeClusterORM, error) {
	to := KubeClusterORM{}
	var err error
	if prehook, ok := interface{}(m).(KubeClusterWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&KubeCluster{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	to.Name = m.Name
	to.Description = m.Description
	if m.NetworkId != nil {
		if v, err := resource1.Decode(&Network{}, m.NetworkId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.NetworkId = &vv
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(KubeClusterWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *KubeClusterORM) ToPB(ctx context.Context) (KubeCluster, error) {
	to := KubeCluster{}
	var err error
	if prehook, ok := interface{}(m).(KubeClusterWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&KubeCluster{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	if m.NetworkId != nil {
		if v, err := resource1.Encode(&Network{}, *m.NetworkId); err != nil {
			return to, err
		} else {
			to.NetworkId = v
		}
	}
	if posthook, ok := interface{}(m).(KubeClusterWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type KubeCluster the arg will be the target, the caller the one being converted from

// KubeClusterBeforeToORM called before default ToORM code
type KubeClusterWithBeforeToORM interface {
	BeforeToORM(context.Context, *KubeClusterORM) error
}

// KubeClusterAfterToORM called after default ToORM code
type KubeClusterWithAfterToORM interface {
	AfterToORM(context.Context, *KubeClusterORM) error
}

// KubeClusterBeforeToPB called before default ToPB code
type KubeClusterWithBeforeToPB interface {
	BeforeToPB(context.Context, *KubeCluster) error
}

// KubeClusterAfterToPB called after default ToPB code
type KubeClusterWithAfterToPB interface {
	AfterToPB(context.Context, *KubeCluster) error
}

type DeploymentORM struct {
	AccountID             string
	ApplicationInstanceId *string      `gorm:"type:UUID"`
	Artifact              *ArtifactORM `gorm:"foreignkey:ArtifactId;association_foreignkey:Id"`
	ArtifactId            *string      `gorm:"type:UUID"`
	Description           string
	Id                    string          `gorm:"type:UUID;primary_key"`
	KubeCluster           *KubeClusterORM `gorm:"foreignkey:KubeClusterId;association_foreignkey:Id"`
	KubeClusterId         *string         `gorm:"type:UUID"`
	Name                  string
}

// TableName overrides the default tablename generated by GORM
func (DeploymentORM) TableName() string {
	return "deployments"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Deployment) ToORM(ctx context.Context) (DeploymentORM, error) {
	to := DeploymentORM{}
	var err error
	if prehook, ok := interface{}(m).(DeploymentWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&Deployment{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	to.Name = m.Name
	to.Description = m.Description
	if m.Artifact != nil {
		tempArtifact, err := m.Artifact.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Artifact = &tempArtifact
	}
	if m.ArtifactId != nil {
		if v, err := resource1.Decode(&Artifact{}, m.ArtifactId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.ArtifactId = &vv
		}
	}
	if m.KubeCluster != nil {
		tempKubeCluster, err := m.KubeCluster.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.KubeCluster = &tempKubeCluster
	}
	if m.KubeClusterId != nil {
		if v, err := resource1.Decode(&KubeCluster{}, m.KubeClusterId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.KubeClusterId = &vv
		}
	}
	if m.ApplicationInstanceId != nil {
		if v, err := resource1.Decode(&ApplicationInstance{}, m.ApplicationInstanceId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.ApplicationInstanceId = &vv
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(DeploymentWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DeploymentORM) ToPB(ctx context.Context) (Deployment, error) {
	to := Deployment{}
	var err error
	if prehook, ok := interface{}(m).(DeploymentWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Deployment{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Description = m.Description
	if m.Artifact != nil {
		tempArtifact, err := m.Artifact.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Artifact = &tempArtifact
	}
	if m.ArtifactId != nil {
		if v, err := resource1.Encode(&Artifact{}, *m.ArtifactId); err != nil {
			return to, err
		} else {
			to.ArtifactId = v
		}
	}
	if m.KubeCluster != nil {
		tempKubeCluster, err := m.KubeCluster.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.KubeCluster = &tempKubeCluster
	}
	if m.KubeClusterId != nil {
		if v, err := resource1.Encode(&KubeCluster{}, *m.KubeClusterId); err != nil {
			return to, err
		} else {
			to.KubeClusterId = v
		}
	}
	if m.ApplicationInstanceId != nil {
		if v, err := resource1.Encode(&ApplicationInstance{}, *m.ApplicationInstanceId); err != nil {
			return to, err
		} else {
			to.ApplicationInstanceId = v
		}
	}
	if posthook, ok := interface{}(m).(DeploymentWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Deployment the arg will be the target, the caller the one being converted from

// DeploymentBeforeToORM called before default ToORM code
type DeploymentWithBeforeToORM interface {
	BeforeToORM(context.Context, *DeploymentORM) error
}

// DeploymentAfterToORM called after default ToORM code
type DeploymentWithAfterToORM interface {
	AfterToORM(context.Context, *DeploymentORM) error
}

// DeploymentBeforeToPB called before default ToPB code
type DeploymentWithBeforeToPB interface {
	BeforeToPB(context.Context, *Deployment) error
}

// DeploymentAfterToPB called after default ToPB code
type DeploymentWithAfterToPB interface {
	AfterToPB(context.Context, *Deployment) error
}

// DefaultCreateCloudProvider executes a basic gorm create call
func DefaultCreateCloudProvider(ctx context.Context, in *CloudProvider, db *gorm1.DB) (*CloudProvider, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CloudProviderORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CloudProviderORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadCloudProvider executes a basic gorm read call
func DefaultReadCloudProvider(ctx context.Context, in *CloudProvider, db *gorm1.DB, fs *query1.FieldSelection) (*CloudProvider, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &CloudProviderORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := CloudProviderORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CloudProviderORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CloudProviderORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type CloudProviderORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type CloudProviderORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteCloudProvider(ctx context.Context, in *CloudProvider, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CloudProviderORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CloudProviderORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CloudProviderORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteCloudProviderSet(ctx context.Context, in []*CloudProvider, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CloudProviderORM{})).(CloudProviderORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&CloudProviderORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CloudProviderORM{})).(CloudProviderORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CloudProviderORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CloudProvider, *gorm1.DB) (*gorm1.DB, error)
}
type CloudProviderORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CloudProvider, *gorm1.DB) error
}

// DefaultStrictUpdateCloudProvider clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCloudProvider(ctx context.Context, in *CloudProvider, db *gorm1.DB) (*CloudProvider, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCloudProvider")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &CloudProviderORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterRegions := RegionORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterRegions.CloudProviderId = new(string)
	*filterRegions.CloudProviderId = ormObj.Id
	if err = db.Where(filterRegions).Delete(RegionORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CloudProviderORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CloudProviderORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CloudProviderORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchCloudProvider executes a basic gorm update call with patch behavior
func DefaultPatchCloudProvider(ctx context.Context, in *CloudProvider, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*CloudProvider, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj CloudProvider
	var err error
	if hook, ok := interface{}(&pbObj).(CloudProviderWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCloudProvider(ctx, &CloudProvider{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CloudProviderWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCloudProvider(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CloudProviderWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCloudProvider(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CloudProviderWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CloudProviderWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CloudProvider, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type CloudProviderWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CloudProvider, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type CloudProviderWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CloudProvider, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type CloudProviderWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CloudProvider, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetCloudProvider executes a bulk gorm update call with patch behavior
func DefaultPatchSetCloudProvider(ctx context.Context, objects []*CloudProvider, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*CloudProvider, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CloudProvider, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCloudProvider(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCloudProvider patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCloudProvider(ctx context.Context, patchee *CloudProvider, patcher *CloudProvider, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*CloudProvider, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Provider" {
			patchee.Provider = patcher.Provider
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"Regions" {
			patchee.Regions = patcher.Regions
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCloudProvider executes a gorm list call
func DefaultListCloudProvider(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*CloudProvider, error) {
	in := CloudProvider{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &CloudProviderORM{}, &CloudProvider{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CloudProviderORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CloudProviderORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CloudProvider{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CloudProviderORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type CloudProviderORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type CloudProviderORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]CloudProviderORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateRegion executes a basic gorm create call
func DefaultCreateRegion(ctx context.Context, in *Region, db *gorm1.DB) (*Region, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type RegionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RegionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadRegion executes a basic gorm read call
func DefaultReadRegion(ctx context.Context, in *Region, db *gorm1.DB, fs *query1.FieldSelection) (*Region, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &RegionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := RegionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(RegionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type RegionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type RegionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type RegionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteRegion(ctx context.Context, in *Region, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&RegionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type RegionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RegionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteRegionSet(ctx context.Context, in []*Region, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&RegionORM{})).(RegionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&RegionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&RegionORM{})).(RegionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type RegionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Region, *gorm1.DB) (*gorm1.DB, error)
}
type RegionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Region, *gorm1.DB) error
}

// DefaultStrictUpdateRegion clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateRegion(ctx context.Context, in *Region, db *gorm1.DB) (*Region, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateRegion")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &RegionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterNetworks := NetworkORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterNetworks.RegionId = new(string)
	*filterNetworks.RegionId = ormObj.Id
	if err = db.Where(filterNetworks).Delete(NetworkORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type RegionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RegionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RegionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchRegion executes a basic gorm update call with patch behavior
func DefaultPatchRegion(ctx context.Context, in *Region, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Region, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Region
	var err error
	if hook, ok := interface{}(&pbObj).(RegionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadRegion(ctx, &Region{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(RegionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskRegion(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(RegionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateRegion(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(RegionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type RegionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Region, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type RegionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Region, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type RegionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Region, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type RegionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Region, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetRegion executes a bulk gorm update call with patch behavior
func DefaultPatchSetRegion(ctx context.Context, objects []*Region, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Region, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Region, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchRegion(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskRegion patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskRegion(ctx context.Context, patchee *Region, patcher *Region, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Region, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Networks" {
			patchee.Networks = patcher.Networks
			continue
		}
		if f == prefix+"CloudProviderId" {
			patchee.CloudProviderId = patcher.CloudProviderId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListRegion executes a gorm list call
func DefaultListRegion(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Region, error) {
	in := Region{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &RegionORM{}, &Region{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []RegionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RegionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Region{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type RegionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type RegionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type RegionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]RegionORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateNetwork executes a basic gorm create call
func DefaultCreateNetwork(ctx context.Context, in *Network, db *gorm1.DB) (*Network, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NetworkORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NetworkORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NetworkORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NetworkORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadNetwork executes a basic gorm read call
func DefaultReadNetwork(ctx context.Context, in *Network, db *gorm1.DB, fs *query1.FieldSelection) (*Network, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NetworkORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &NetworkORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NetworkORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := NetworkORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NetworkORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NetworkORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type NetworkORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type NetworkORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteNetwork(ctx context.Context, in *Network, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NetworkORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NetworkORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NetworkORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NetworkORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NetworkORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteNetworkSet(ctx context.Context, in []*Network, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&NetworkORM{})).(NetworkORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&NetworkORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NetworkORM{})).(NetworkORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NetworkORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Network, *gorm1.DB) (*gorm1.DB, error)
}
type NetworkORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Network, *gorm1.DB) error
}

// DefaultStrictUpdateNetwork clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNetwork(ctx context.Context, in *Network, db *gorm1.DB) (*Network, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNetwork")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &NetworkORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NetworkORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NetworkORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NetworkORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NetworkORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NetworkORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NetworkORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchNetwork executes a basic gorm update call with patch behavior
func DefaultPatchNetwork(ctx context.Context, in *Network, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Network, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Network
	var err error
	if hook, ok := interface{}(&pbObj).(NetworkWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadNetwork(ctx, &Network{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(NetworkWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNetwork(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NetworkWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNetwork(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NetworkWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NetworkWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Network, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type NetworkWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Network, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type NetworkWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Network, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type NetworkWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Network, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetNetwork executes a bulk gorm update call with patch behavior
func DefaultPatchSetNetwork(ctx context.Context, objects []*Network, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Network, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Network, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNetwork(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNetwork patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNetwork(ctx context.Context, patchee *Network, patcher *Network, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Network, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"RegionId" {
			patchee.RegionId = patcher.RegionId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNetwork executes a gorm list call
func DefaultListNetwork(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Network, error) {
	in := Network{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NetworkORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &NetworkORM{}, &Network{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NetworkORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []NetworkORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NetworkORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Network{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NetworkORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type NetworkORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type NetworkORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]NetworkORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateLifecycle executes a basic gorm create call
func DefaultCreateLifecycle(ctx context.Context, in *Lifecycle, db *gorm1.DB) (*Lifecycle, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LifecycleORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LifecycleORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type LifecycleORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LifecycleORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadLifecycle executes a basic gorm read call
func DefaultReadLifecycle(ctx context.Context, in *Lifecycle, db *gorm1.DB, fs *query1.FieldSelection) (*Lifecycle, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LifecycleORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &LifecycleORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LifecycleORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := LifecycleORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(LifecycleORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type LifecycleORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type LifecycleORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type LifecycleORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteLifecycle(ctx context.Context, in *Lifecycle, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LifecycleORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&LifecycleORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(LifecycleORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type LifecycleORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LifecycleORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteLifecycleSet(ctx context.Context, in []*Lifecycle, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&LifecycleORM{})).(LifecycleORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&LifecycleORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&LifecycleORM{})).(LifecycleORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type LifecycleORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Lifecycle, *gorm1.DB) (*gorm1.DB, error)
}
type LifecycleORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Lifecycle, *gorm1.DB) error
}

// DefaultStrictUpdateLifecycle clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateLifecycle(ctx context.Context, in *Lifecycle, db *gorm1.DB) (*Lifecycle, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateLifecycle")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &LifecycleORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(LifecycleORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAppConfig := AppConfigORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterAppConfig.LifecycleId = new(string)
	*filterAppConfig.LifecycleId = ormObj.Id
	if err = db.Where(filterAppConfig).Delete(AppConfigORM{}).Error; err != nil {
		return nil, err
	}
	filterAppVersion := AppVersionORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterAppVersion.LifecycleId = new(string)
	*filterAppVersion.LifecycleId = ormObj.Id
	if err = db.Where(filterAppVersion).Delete(AppVersionORM{}).Error; err != nil {
		return nil, err
	}
	filterEnvironments := EnvironmentORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterEnvironments.LifecycleId = new(string)
	*filterEnvironments.LifecycleId = ormObj.Id
	if err = db.Where(filterEnvironments).Delete(EnvironmentORM{}).Error; err != nil {
		return nil, err
	}
	filterLifecycles := LifecycleORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterLifecycles.LifecycleId = new(string)
	*filterLifecycles.LifecycleId = ormObj.Id
	if err = db.Where(filterLifecycles).Delete(LifecycleORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LifecycleORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LifecycleORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type LifecycleORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LifecycleORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LifecycleORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchLifecycle executes a basic gorm update call with patch behavior
func DefaultPatchLifecycle(ctx context.Context, in *Lifecycle, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Lifecycle, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Lifecycle
	var err error
	if hook, ok := interface{}(&pbObj).(LifecycleWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadLifecycle(ctx, &Lifecycle{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(LifecycleWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskLifecycle(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(LifecycleWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateLifecycle(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(LifecycleWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type LifecycleWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Lifecycle, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type LifecycleWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Lifecycle, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type LifecycleWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Lifecycle, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type LifecycleWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Lifecycle, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetLifecycle executes a bulk gorm update call with patch behavior
func DefaultPatchSetLifecycle(ctx context.Context, objects []*Lifecycle, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Lifecycle, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Lifecycle, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchLifecycle(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskLifecycle patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskLifecycle(ctx context.Context, patchee *Lifecycle, patcher *Lifecycle, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Lifecycle, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"ConfigYaml" {
			patchee.ConfigYaml = patcher.ConfigYaml
			continue
		}
		if f == prefix+"Environments" {
			patchee.Environments = patcher.Environments
			continue
		}
		if f == prefix+"Lifecycles" {
			patchee.Lifecycles = patcher.Lifecycles
			continue
		}
		if f == prefix+"AppConfig" {
			patchee.AppConfig = patcher.AppConfig
			continue
		}
		if f == prefix+"AppVersion" {
			patchee.AppVersion = patcher.AppVersion
			continue
		}
		if f == prefix+"LifecycleId" {
			patchee.LifecycleId = patcher.LifecycleId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListLifecycle executes a gorm list call
func DefaultListLifecycle(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Lifecycle, error) {
	in := Lifecycle{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LifecycleORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &LifecycleORM{}, &Lifecycle{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LifecycleORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []LifecycleORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LifecycleORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Lifecycle{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type LifecycleORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type LifecycleORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type LifecycleORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]LifecycleORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateChartVersion executes a basic gorm create call
func DefaultCreateChartVersion(ctx context.Context, in *ChartVersion, db *gorm1.DB) (*ChartVersion, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ChartVersionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ChartVersionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadChartVersion executes a basic gorm read call
func DefaultReadChartVersion(ctx context.Context, in *ChartVersion, db *gorm1.DB, fs *query1.FieldSelection) (*ChartVersion, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &ChartVersionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := ChartVersionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ChartVersionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ChartVersionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ChartVersionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ChartVersionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteChartVersion(ctx context.Context, in *ChartVersion, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ChartVersionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ChartVersionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ChartVersionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteChartVersionSet(ctx context.Context, in []*ChartVersion, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ChartVersionORM{})).(ChartVersionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ChartVersionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ChartVersionORM{})).(ChartVersionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ChartVersionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ChartVersion, *gorm1.DB) (*gorm1.DB, error)
}
type ChartVersionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ChartVersion, *gorm1.DB) error
}

// DefaultStrictUpdateChartVersion clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateChartVersion(ctx context.Context, in *ChartVersion, db *gorm1.DB) (*ChartVersion, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateChartVersion")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ChartVersionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ChartVersionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ChartVersionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ChartVersionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchChartVersion executes a basic gorm update call with patch behavior
func DefaultPatchChartVersion(ctx context.Context, in *ChartVersion, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ChartVersion, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ChartVersion
	var err error
	if hook, ok := interface{}(&pbObj).(ChartVersionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadChartVersion(ctx, &ChartVersion{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ChartVersionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskChartVersion(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ChartVersionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateChartVersion(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ChartVersionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ChartVersionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ChartVersion, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ChartVersionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ChartVersion, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ChartVersionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ChartVersion, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ChartVersionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ChartVersion, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetChartVersion executes a bulk gorm update call with patch behavior
func DefaultPatchSetChartVersion(ctx context.Context, objects []*ChartVersion, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ChartVersion, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ChartVersion, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchChartVersion(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskChartVersion patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskChartVersion(ctx context.Context, patchee *ChartVersion, patcher *ChartVersion, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ChartVersion, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedChartStore bool
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Repo" {
			patchee.Repo = patcher.Repo
			continue
		}
		if f == prefix+"Version" {
			patchee.Version = patcher.Version
			continue
		}
		if !updatedChartStore && strings.HasPrefix(f, prefix+"ChartStore") {
			patchee.ChartStore = patcher.ChartStore
			updatedChartStore = true
			continue
		}
		if f == prefix+"ApplicationId" {
			patchee.ApplicationId = patcher.ApplicationId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListChartVersion executes a gorm list call
func DefaultListChartVersion(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ChartVersion, error) {
	in := ChartVersion{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ChartVersionORM{}, &ChartVersion{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ChartVersionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChartVersionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ChartVersion{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ChartVersionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ChartVersionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ChartVersionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ChartVersionORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateAppConfig executes a basic gorm create call
func DefaultCreateAppConfig(ctx context.Context, in *AppConfig, db *gorm1.DB) (*AppConfig, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppConfigORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppConfigORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AppConfigORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AppConfigORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadAppConfig executes a basic gorm read call
func DefaultReadAppConfig(ctx context.Context, in *AppConfig, db *gorm1.DB, fs *query1.FieldSelection) (*AppConfig, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AppConfigORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &AppConfigORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppConfigORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := AppConfigORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AppConfigORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AppConfigORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type AppConfigORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type AppConfigORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteAppConfig(ctx context.Context, in *AppConfig, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AppConfigORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AppConfigORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AppConfigORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AppConfigORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AppConfigORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteAppConfigSet(ctx context.Context, in []*AppConfig, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AppConfigORM{})).(AppConfigORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&AppConfigORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AppConfigORM{})).(AppConfigORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AppConfigORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AppConfig, *gorm1.DB) (*gorm1.DB, error)
}
type AppConfigORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AppConfig, *gorm1.DB) error
}

// DefaultStrictUpdateAppConfig clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAppConfig(ctx context.Context, in *AppConfig, db *gorm1.DB) (*AppConfig, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAppConfig")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &AppConfigORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AppConfigORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppConfigORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppConfigORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AppConfigORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AppConfigORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AppConfigORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchAppConfig executes a basic gorm update call with patch behavior
func DefaultPatchAppConfig(ctx context.Context, in *AppConfig, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*AppConfig, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj AppConfig
	var err error
	if hook, ok := interface{}(&pbObj).(AppConfigWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAppConfig(ctx, &AppConfig{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AppConfigWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAppConfig(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AppConfigWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAppConfig(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AppConfigWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AppConfigWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AppConfig, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AppConfigWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AppConfig, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AppConfigWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AppConfig, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AppConfigWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AppConfig, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetAppConfig executes a bulk gorm update call with patch behavior
func DefaultPatchSetAppConfig(ctx context.Context, objects []*AppConfig, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*AppConfig, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AppConfig, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAppConfig(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAppConfig patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAppConfig(ctx context.Context, patchee *AppConfig, patcher *AppConfig, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*AppConfig, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"ConfigYaml" {
			patchee.ConfigYaml = patcher.ConfigYaml
			continue
		}
		if f == prefix+"ApplicationId" {
			patchee.ApplicationId = patcher.ApplicationId
			continue
		}
		if f == prefix+"LifecycleId" {
			patchee.LifecycleId = patcher.LifecycleId
			continue
		}
		if f == prefix+"EnvironmentId" {
			patchee.EnvironmentId = patcher.EnvironmentId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAppConfig executes a gorm list call
func DefaultListAppConfig(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*AppConfig, error) {
	in := AppConfig{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppConfigORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &AppConfigORM{}, &AppConfig{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppConfigORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AppConfigORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppConfigORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AppConfig{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AppConfigORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type AppConfigORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type AppConfigORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]AppConfigORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateEnvironment executes a basic gorm create call
func DefaultCreateEnvironment(ctx context.Context, in *Environment, db *gorm1.DB) (*Environment, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EnvironmentORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EnvironmentORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadEnvironment executes a basic gorm read call
func DefaultReadEnvironment(ctx context.Context, in *Environment, db *gorm1.DB, fs *query1.FieldSelection) (*Environment, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &EnvironmentORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := EnvironmentORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EnvironmentORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EnvironmentORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type EnvironmentORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type EnvironmentORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteEnvironment(ctx context.Context, in *Environment, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EnvironmentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type EnvironmentORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EnvironmentORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteEnvironmentSet(ctx context.Context, in []*Environment, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&EnvironmentORM{})).(EnvironmentORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&EnvironmentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&EnvironmentORM{})).(EnvironmentORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EnvironmentORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Environment, *gorm1.DB) (*gorm1.DB, error)
}
type EnvironmentORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Environment, *gorm1.DB) error
}

// DefaultStrictUpdateEnvironment clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEnvironment(ctx context.Context, in *Environment, db *gorm1.DB) (*Environment, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEnvironment")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &EnvironmentORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAppConfig := AppConfigORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterAppConfig.EnvironmentId = new(string)
	*filterAppConfig.EnvironmentId = ormObj.Id
	if err = db.Where(filterAppConfig).Delete(AppConfigORM{}).Error; err != nil {
		return nil, err
	}
	filterAppVersion := AppVersionORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterAppVersion.EnvironmentId = new(string)
	*filterAppVersion.EnvironmentId = ormObj.Id
	if err = db.Where(filterAppVersion).Delete(AppVersionORM{}).Error; err != nil {
		return nil, err
	}
	filterApplicationInstances := ApplicationInstanceORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterApplicationInstances.EnvironmentId = new(string)
	*filterApplicationInstances.EnvironmentId = ormObj.Id
	if err = db.Where(filterApplicationInstances).Delete(ApplicationInstanceORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type EnvironmentORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EnvironmentORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EnvironmentORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchEnvironment executes a basic gorm update call with patch behavior
func DefaultPatchEnvironment(ctx context.Context, in *Environment, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Environment, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Environment
	var err error
	if hook, ok := interface{}(&pbObj).(EnvironmentWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadEnvironment(ctx, &Environment{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(EnvironmentWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEnvironment(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EnvironmentWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEnvironment(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EnvironmentWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EnvironmentWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Environment, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EnvironmentWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Environment, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EnvironmentWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Environment, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EnvironmentWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Environment, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetEnvironment executes a bulk gorm update call with patch behavior
func DefaultPatchSetEnvironment(ctx context.Context, objects []*Environment, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Environment, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Environment, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchEnvironment(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskEnvironment patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEnvironment(ctx context.Context, patchee *Environment, patcher *Environment, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Environment, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"ConfigYaml" {
			patchee.ConfigYaml = patcher.ConfigYaml
			continue
		}
		if f == prefix+"ApplicationInstances" {
			patchee.ApplicationInstances = patcher.ApplicationInstances
			continue
		}
		if f == prefix+"AppConfig" {
			patchee.AppConfig = patcher.AppConfig
			continue
		}
		if f == prefix+"AppVersion" {
			patchee.AppVersion = patcher.AppVersion
			continue
		}
		if f == prefix+"LifecycleId" {
			patchee.LifecycleId = patcher.LifecycleId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEnvironment executes a gorm list call
func DefaultListEnvironment(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Environment, error) {
	in := Environment{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &EnvironmentORM{}, &Environment{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []EnvironmentORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EnvironmentORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Environment{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EnvironmentORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type EnvironmentORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type EnvironmentORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]EnvironmentORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateApplication executes a basic gorm create call
func DefaultCreateApplication(ctx context.Context, in *Application, db *gorm1.DB) (*Application, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ApplicationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadApplication executes a basic gorm read call
func DefaultReadApplication(ctx context.Context, in *Application, db *gorm1.DB, fs *query1.FieldSelection) (*Application, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &ApplicationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := ApplicationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ApplicationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ApplicationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ApplicationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ApplicationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteApplication(ctx context.Context, in *Application, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ApplicationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ApplicationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteApplicationSet(ctx context.Context, in []*Application, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ApplicationORM{})).(ApplicationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ApplicationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ApplicationORM{})).(ApplicationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ApplicationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Application, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Application, *gorm1.DB) error
}

// DefaultStrictUpdateApplication clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateApplication(ctx context.Context, in *Application, db *gorm1.DB) (*Application, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateApplication")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ApplicationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ApplicationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchApplication executes a basic gorm update call with patch behavior
func DefaultPatchApplication(ctx context.Context, in *Application, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Application, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Application
	var err error
	if hook, ok := interface{}(&pbObj).(ApplicationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadApplication(ctx, &Application{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ApplicationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskApplication(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ApplicationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateApplication(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ApplicationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ApplicationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Application, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Application, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Application, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Application, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetApplication executes a bulk gorm update call with patch behavior
func DefaultPatchSetApplication(ctx context.Context, objects []*Application, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Application, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Application, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchApplication(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskApplication patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskApplication(ctx context.Context, patchee *Application, patcher *Application, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Application, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Chart" {
			patchee.Chart = patcher.Chart
			continue
		}
		if f == prefix+"Repo" {
			patchee.Repo = patcher.Repo
			continue
		}
		if f == prefix+"TicketLink" {
			patchee.TicketLink = patcher.TicketLink
			continue
		}
		if f == prefix+"ConfigYaml" {
			patchee.ConfigYaml = patcher.ConfigYaml
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListApplication executes a gorm list call
func DefaultListApplication(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Application, error) {
	in := Application{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ApplicationORM{}, &Application{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ApplicationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Application{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ApplicationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ApplicationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ApplicationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ApplicationORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateAppVersion executes a basic gorm create call
func DefaultCreateAppVersion(ctx context.Context, in *AppVersion, db *gorm1.DB) (*AppVersion, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AppVersionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AppVersionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadAppVersion executes a basic gorm read call
func DefaultReadAppVersion(ctx context.Context, in *AppVersion, db *gorm1.DB, fs *query1.FieldSelection) (*AppVersion, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &AppVersionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := AppVersionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AppVersionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AppVersionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type AppVersionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type AppVersionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteAppVersion(ctx context.Context, in *AppVersion, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AppVersionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AppVersionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AppVersionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteAppVersionSet(ctx context.Context, in []*AppVersion, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AppVersionORM{})).(AppVersionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&AppVersionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AppVersionORM{})).(AppVersionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AppVersionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AppVersion, *gorm1.DB) (*gorm1.DB, error)
}
type AppVersionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AppVersion, *gorm1.DB) error
}

// DefaultStrictUpdateAppVersion clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAppVersion(ctx context.Context, in *AppVersion, db *gorm1.DB) (*AppVersion, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAppVersion")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &AppVersionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AppVersionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AppVersionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AppVersionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchAppVersion executes a basic gorm update call with patch behavior
func DefaultPatchAppVersion(ctx context.Context, in *AppVersion, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*AppVersion, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj AppVersion
	var err error
	if hook, ok := interface{}(&pbObj).(AppVersionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAppVersion(ctx, &AppVersion{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AppVersionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAppVersion(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AppVersionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAppVersion(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AppVersionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AppVersionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AppVersion, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AppVersionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AppVersion, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AppVersionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AppVersion, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AppVersionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AppVersion, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetAppVersion executes a bulk gorm update call with patch behavior
func DefaultPatchSetAppVersion(ctx context.Context, objects []*AppVersion, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*AppVersion, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AppVersion, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAppVersion(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAppVersion patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAppVersion(ctx context.Context, patchee *AppVersion, patcher *AppVersion, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*AppVersion, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedChartVersion bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if !updatedChartVersion && strings.HasPrefix(f, prefix+"ChartVersion.") {
			updatedChartVersion = true
			if patcher.ChartVersion == nil {
				patchee.ChartVersion = nil
				continue
			}
			if patchee.ChartVersion == nil {
				patchee.ChartVersion = &ChartVersion{}
			}
			if o, err := DefaultApplyFieldMaskChartVersion(ctx, patchee.ChartVersion, patcher.ChartVersion, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"ChartVersion.", db); err != nil {
				return nil, err
			} else {
				patchee.ChartVersion = o
			}
			continue
		}
		if f == prefix+"ChartVersion" {
			updatedChartVersion = true
			patchee.ChartVersion = patcher.ChartVersion
			continue
		}
		if f == prefix+"ChartVersionId" {
			patchee.ChartVersionId = patcher.ChartVersionId
			continue
		}
		if f == prefix+"ApplicationId" {
			patchee.ApplicationId = patcher.ApplicationId
			continue
		}
		if f == prefix+"LifecycleId" {
			patchee.LifecycleId = patcher.LifecycleId
			continue
		}
		if f == prefix+"EnvironmentId" {
			patchee.EnvironmentId = patcher.EnvironmentId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAppVersion executes a gorm list call
func DefaultListAppVersion(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*AppVersion, error) {
	in := AppVersion{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &AppVersionORM{}, &AppVersion{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AppVersionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AppVersionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AppVersion{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AppVersionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type AppVersionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type AppVersionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]AppVersionORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateApplicationInstance executes a basic gorm create call
func DefaultCreateApplicationInstance(ctx context.Context, in *ApplicationInstance, db *gorm1.DB) (*ApplicationInstance, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ApplicationInstanceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationInstanceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadApplicationInstance executes a basic gorm read call
func DefaultReadApplicationInstance(ctx context.Context, in *ApplicationInstance, db *gorm1.DB, fs *query1.FieldSelection) (*ApplicationInstance, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &ApplicationInstanceORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := ApplicationInstanceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ApplicationInstanceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ApplicationInstanceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ApplicationInstanceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ApplicationInstanceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteApplicationInstance(ctx context.Context, in *ApplicationInstance, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ApplicationInstanceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ApplicationInstanceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationInstanceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteApplicationInstanceSet(ctx context.Context, in []*ApplicationInstance, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ApplicationInstanceORM{})).(ApplicationInstanceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ApplicationInstanceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ApplicationInstanceORM{})).(ApplicationInstanceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ApplicationInstanceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ApplicationInstance, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationInstanceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ApplicationInstance, *gorm1.DB) error
}

// DefaultStrictUpdateApplicationInstance clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateApplicationInstance(ctx context.Context, in *ApplicationInstance, db *gorm1.DB) (*ApplicationInstance, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateApplicationInstance")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ApplicationInstanceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterDeployment := DeploymentORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterDeployment.ApplicationInstanceId = new(string)
	*filterDeployment.ApplicationInstanceId = ormObj.Id
	if err = db.Where(filterDeployment).Delete(DeploymentORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ApplicationInstanceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationInstanceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationInstanceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchApplicationInstance executes a basic gorm update call with patch behavior
func DefaultPatchApplicationInstance(ctx context.Context, in *ApplicationInstance, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ApplicationInstance, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ApplicationInstance
	var err error
	if hook, ok := interface{}(&pbObj).(ApplicationInstanceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadApplicationInstance(ctx, &ApplicationInstance{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ApplicationInstanceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskApplicationInstance(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ApplicationInstanceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateApplicationInstance(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ApplicationInstanceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ApplicationInstanceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ApplicationInstance, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationInstanceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ApplicationInstance, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationInstanceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ApplicationInstance, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ApplicationInstanceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ApplicationInstance, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetApplicationInstance executes a bulk gorm update call with patch behavior
func DefaultPatchSetApplicationInstance(ctx context.Context, objects []*ApplicationInstance, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ApplicationInstance, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ApplicationInstance, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchApplicationInstance(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskApplicationInstance patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskApplicationInstance(ctx context.Context, patchee *ApplicationInstance, patcher *ApplicationInstance, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ApplicationInstance, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedDeployment bool
	var updatedChartVersion bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Enable" {
			patchee.Enable = patcher.Enable
			continue
		}
		if !updatedDeployment && strings.HasPrefix(f, prefix+"Deployment.") {
			updatedDeployment = true
			if patcher.Deployment == nil {
				patchee.Deployment = nil
				continue
			}
			if patchee.Deployment == nil {
				patchee.Deployment = &Deployment{}
			}
			if o, err := DefaultApplyFieldMaskDeployment(ctx, patchee.Deployment, patcher.Deployment, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Deployment.", db); err != nil {
				return nil, err
			} else {
				patchee.Deployment = o
			}
			continue
		}
		if f == prefix+"Deployment" {
			updatedDeployment = true
			patchee.Deployment = patcher.Deployment
			continue
		}
		if f == prefix+"ConfigYaml" {
			patchee.ConfigYaml = patcher.ConfigYaml
			continue
		}
		if !updatedChartVersion && strings.HasPrefix(f, prefix+"ChartVersion.") {
			updatedChartVersion = true
			if patcher.ChartVersion == nil {
				patchee.ChartVersion = nil
				continue
			}
			if patchee.ChartVersion == nil {
				patchee.ChartVersion = &ChartVersion{}
			}
			if o, err := DefaultApplyFieldMaskChartVersion(ctx, patchee.ChartVersion, patcher.ChartVersion, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"ChartVersion.", db); err != nil {
				return nil, err
			} else {
				patchee.ChartVersion = o
			}
			continue
		}
		if f == prefix+"ChartVersion" {
			updatedChartVersion = true
			patchee.ChartVersion = patcher.ChartVersion
			continue
		}
		if f == prefix+"ChartVersionId" {
			patchee.ChartVersionId = patcher.ChartVersionId
			continue
		}
		if f == prefix+"EnvironmentId" {
			patchee.EnvironmentId = patcher.EnvironmentId
			continue
		}
		if f == prefix+"ApplicationId" {
			patchee.ApplicationId = patcher.ApplicationId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListApplicationInstance executes a gorm list call
func DefaultListApplicationInstance(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ApplicationInstance, error) {
	in := ApplicationInstance{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ApplicationInstanceORM{}, &ApplicationInstance{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ApplicationInstanceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ApplicationInstanceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ApplicationInstance{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ApplicationInstanceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ApplicationInstanceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ApplicationInstanceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ApplicationInstanceORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateVault executes a basic gorm create call
func DefaultCreateVault(ctx context.Context, in *Vault, db *gorm1.DB) (*Vault, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type VaultORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type VaultORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadVault executes a basic gorm read call
func DefaultReadVault(ctx context.Context, in *Vault, db *gorm1.DB, fs *query1.FieldSelection) (*Vault, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &VaultORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := VaultORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(VaultORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type VaultORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type VaultORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type VaultORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteVault(ctx context.Context, in *Vault, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&VaultORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type VaultORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type VaultORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteVaultSet(ctx context.Context, in []*Vault, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&VaultORM{})).(VaultORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&VaultORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&VaultORM{})).(VaultORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type VaultORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Vault, *gorm1.DB) (*gorm1.DB, error)
}
type VaultORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Vault, *gorm1.DB) error
}

// DefaultStrictUpdateVault clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateVault(ctx context.Context, in *Vault, db *gorm1.DB) (*Vault, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateVault")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &VaultORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterSecrets := SecretORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterSecrets.VaultId = new(string)
	*filterSecrets.VaultId = ormObj.Id
	if err = db.Where(filterSecrets).Delete(SecretORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type VaultORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type VaultORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type VaultORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchVault executes a basic gorm update call with patch behavior
func DefaultPatchVault(ctx context.Context, in *Vault, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Vault, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Vault
	var err error
	if hook, ok := interface{}(&pbObj).(VaultWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadVault(ctx, &Vault{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(VaultWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskVault(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(VaultWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateVault(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(VaultWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type VaultWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Vault, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type VaultWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Vault, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type VaultWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Vault, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type VaultWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Vault, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetVault executes a bulk gorm update call with patch behavior
func DefaultPatchSetVault(ctx context.Context, objects []*Vault, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Vault, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Vault, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchVault(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskVault patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskVault(ctx context.Context, patchee *Vault, patcher *Vault, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Vault, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Secrets" {
			patchee.Secrets = patcher.Secrets
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListVault executes a gorm list call
func DefaultListVault(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Vault, error) {
	in := Vault{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &VaultORM{}, &Vault{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []VaultORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VaultORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Vault{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type VaultORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type VaultORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type VaultORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]VaultORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateSecret executes a basic gorm create call
func DefaultCreateSecret(ctx context.Context, in *Secret, db *gorm1.DB) (*Secret, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SecretORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SecretORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadSecret executes a basic gorm read call
func DefaultReadSecret(ctx context.Context, in *Secret, db *gorm1.DB, fs *query1.FieldSelection) (*Secret, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &SecretORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := SecretORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SecretORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SecretORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type SecretORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type SecretORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteSecret(ctx context.Context, in *Secret, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SecretORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SecretORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SecretORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteSecretSet(ctx context.Context, in []*Secret, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&SecretORM{})).(SecretORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&SecretORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SecretORM{})).(SecretORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SecretORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Secret, *gorm1.DB) (*gorm1.DB, error)
}
type SecretORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Secret, *gorm1.DB) error
}

// DefaultStrictUpdateSecret clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSecret(ctx context.Context, in *Secret, db *gorm1.DB) (*Secret, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSecret")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &SecretORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SecretORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SecretORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SecretORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchSecret executes a basic gorm update call with patch behavior
func DefaultPatchSecret(ctx context.Context, in *Secret, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Secret, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Secret
	var err error
	if hook, ok := interface{}(&pbObj).(SecretWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSecret(ctx, &Secret{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SecretWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSecret(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SecretWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSecret(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SecretWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SecretWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Secret, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SecretWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Secret, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SecretWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Secret, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SecretWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Secret, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetSecret executes a bulk gorm update call with patch behavior
func DefaultPatchSetSecret(ctx context.Context, objects []*Secret, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Secret, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Secret, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSecret(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSecret patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSecret(ctx context.Context, patchee *Secret, patcher *Secret, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Secret, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Path" {
			patchee.Path = patcher.Path
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Key" {
			patchee.Key = patcher.Key
			continue
		}
		if f == prefix+"VaultId" {
			patchee.VaultId = patcher.VaultId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSecret executes a gorm list call
func DefaultListSecret(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Secret, error) {
	in := Secret{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &SecretORM{}, &Secret{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SecretORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SecretORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Secret{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SecretORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type SecretORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type SecretORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]SecretORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateArtifact executes a basic gorm create call
func DefaultCreateArtifact(ctx context.Context, in *Artifact, db *gorm1.DB) (*Artifact, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ArtifactORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ArtifactORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadArtifact executes a basic gorm read call
func DefaultReadArtifact(ctx context.Context, in *Artifact, db *gorm1.DB, fs *query1.FieldSelection) (*Artifact, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &ArtifactORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := ArtifactORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ArtifactORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ArtifactORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ArtifactORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type ArtifactORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteArtifact(ctx context.Context, in *Artifact, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ArtifactORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ArtifactORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ArtifactORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteArtifactSet(ctx context.Context, in []*Artifact, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ArtifactORM{})).(ArtifactORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ArtifactORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ArtifactORM{})).(ArtifactORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ArtifactORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Artifact, *gorm1.DB) (*gorm1.DB, error)
}
type ArtifactORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Artifact, *gorm1.DB) error
}

// DefaultStrictUpdateArtifact clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateArtifact(ctx context.Context, in *Artifact, db *gorm1.DB) (*Artifact, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateArtifact")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ArtifactORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ArtifactORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ArtifactORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ArtifactORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchArtifact executes a basic gorm update call with patch behavior
func DefaultPatchArtifact(ctx context.Context, in *Artifact, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Artifact, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Artifact
	var err error
	if hook, ok := interface{}(&pbObj).(ArtifactWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadArtifact(ctx, &Artifact{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ArtifactWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskArtifact(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ArtifactWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateArtifact(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ArtifactWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ArtifactWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Artifact, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ArtifactWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Artifact, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ArtifactWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Artifact, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ArtifactWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Artifact, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetArtifact executes a bulk gorm update call with patch behavior
func DefaultPatchSetArtifact(ctx context.Context, objects []*Artifact, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Artifact, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Artifact, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchArtifact(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskArtifact patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskArtifact(ctx context.Context, patchee *Artifact, patcher *Artifact, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Artifact, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Repo" {
			patchee.Repo = patcher.Repo
			continue
		}
		if f == prefix+"Commit" {
			patchee.Commit = patcher.Commit
			continue
		}
		if f == prefix+"ChartVersionId" {
			patchee.ChartVersionId = patcher.ChartVersionId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListArtifact executes a gorm list call
func DefaultListArtifact(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Artifact, error) {
	in := Artifact{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ArtifactORM{}, &Artifact{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ArtifactORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArtifactORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Artifact{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ArtifactORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ArtifactORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ArtifactORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ArtifactORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateKubeCluster executes a basic gorm create call
func DefaultCreateKubeCluster(ctx context.Context, in *KubeCluster, db *gorm1.DB) (*KubeCluster, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type KubeClusterORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type KubeClusterORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadKubeCluster executes a basic gorm read call
func DefaultReadKubeCluster(ctx context.Context, in *KubeCluster, db *gorm1.DB, fs *query1.FieldSelection) (*KubeCluster, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &KubeClusterORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := KubeClusterORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(KubeClusterORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type KubeClusterORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type KubeClusterORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type KubeClusterORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteKubeCluster(ctx context.Context, in *KubeCluster, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&KubeClusterORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type KubeClusterORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type KubeClusterORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteKubeClusterSet(ctx context.Context, in []*KubeCluster, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&KubeClusterORM{})).(KubeClusterORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&KubeClusterORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&KubeClusterORM{})).(KubeClusterORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type KubeClusterORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*KubeCluster, *gorm1.DB) (*gorm1.DB, error)
}
type KubeClusterORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*KubeCluster, *gorm1.DB) error
}

// DefaultStrictUpdateKubeCluster clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateKubeCluster(ctx context.Context, in *KubeCluster, db *gorm1.DB) (*KubeCluster, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateKubeCluster")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &KubeClusterORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type KubeClusterORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type KubeClusterORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type KubeClusterORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchKubeCluster executes a basic gorm update call with patch behavior
func DefaultPatchKubeCluster(ctx context.Context, in *KubeCluster, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*KubeCluster, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj KubeCluster
	var err error
	if hook, ok := interface{}(&pbObj).(KubeClusterWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadKubeCluster(ctx, &KubeCluster{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(KubeClusterWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskKubeCluster(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(KubeClusterWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateKubeCluster(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(KubeClusterWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type KubeClusterWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *KubeCluster, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type KubeClusterWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *KubeCluster, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type KubeClusterWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *KubeCluster, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type KubeClusterWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *KubeCluster, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetKubeCluster executes a bulk gorm update call with patch behavior
func DefaultPatchSetKubeCluster(ctx context.Context, objects []*KubeCluster, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*KubeCluster, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*KubeCluster, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchKubeCluster(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskKubeCluster patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskKubeCluster(ctx context.Context, patchee *KubeCluster, patcher *KubeCluster, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*KubeCluster, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"NetworkId" {
			patchee.NetworkId = patcher.NetworkId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListKubeCluster executes a gorm list call
func DefaultListKubeCluster(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*KubeCluster, error) {
	in := KubeCluster{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &KubeClusterORM{}, &KubeCluster{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []KubeClusterORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(KubeClusterORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*KubeCluster{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type KubeClusterORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type KubeClusterORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type KubeClusterORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]KubeClusterORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateDeployment executes a basic gorm create call
func DefaultCreateDeployment(ctx context.Context, in *Deployment, db *gorm1.DB) (*Deployment, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DeploymentORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DeploymentORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadDeployment executes a basic gorm read call
func DefaultReadDeployment(ctx context.Context, in *Deployment, db *gorm1.DB, fs *query1.FieldSelection) (*Deployment, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, fs, &DeploymentORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	ormResponse := DeploymentORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(DeploymentORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db, fs); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type DeploymentORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type DeploymentORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) (*gorm1.DB, error)
}
type DeploymentORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB, *query1.FieldSelection) error
}

func DefaultDeleteDeployment(ctx context.Context, in *Deployment, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&DeploymentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type DeploymentORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DeploymentORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteDeploymentSet(ctx context.Context, in []*Deployment, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&DeploymentORM{})).(DeploymentORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&DeploymentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&DeploymentORM{})).(DeploymentORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type DeploymentORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Deployment, *gorm1.DB) (*gorm1.DB, error)
}
type DeploymentORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Deployment, *gorm1.DB) error
}

// DefaultStrictUpdateDeployment clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateDeployment(ctx context.Context, in *Deployment, db *gorm1.DB) (*Deployment, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateDeployment")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &DeploymentORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type DeploymentORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DeploymentORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DeploymentORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchDeployment executes a basic gorm update call with patch behavior
func DefaultPatchDeployment(ctx context.Context, in *Deployment, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Deployment, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Deployment
	var err error
	if hook, ok := interface{}(&pbObj).(DeploymentWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadDeployment(ctx, &Deployment{Id: in.GetId()}, db, nil)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(DeploymentWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskDeployment(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(DeploymentWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateDeployment(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(DeploymentWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type DeploymentWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Deployment, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type DeploymentWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Deployment, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type DeploymentWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Deployment, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type DeploymentWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Deployment, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetDeployment executes a bulk gorm update call with patch behavior
func DefaultPatchSetDeployment(ctx context.Context, objects []*Deployment, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Deployment, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Deployment, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchDeployment(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskDeployment patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDeployment(ctx context.Context, patchee *Deployment, patcher *Deployment, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Deployment, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedArtifact bool
	var updatedKubeCluster bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if !updatedArtifact && strings.HasPrefix(f, prefix+"Artifact.") {
			updatedArtifact = true
			if patcher.Artifact == nil {
				patchee.Artifact = nil
				continue
			}
			if patchee.Artifact == nil {
				patchee.Artifact = &Artifact{}
			}
			if o, err := DefaultApplyFieldMaskArtifact(ctx, patchee.Artifact, patcher.Artifact, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Artifact.", db); err != nil {
				return nil, err
			} else {
				patchee.Artifact = o
			}
			continue
		}
		if f == prefix+"Artifact" {
			updatedArtifact = true
			patchee.Artifact = patcher.Artifact
			continue
		}
		if f == prefix+"ArtifactId" {
			patchee.ArtifactId = patcher.ArtifactId
			continue
		}
		if !updatedKubeCluster && strings.HasPrefix(f, prefix+"KubeCluster.") {
			updatedKubeCluster = true
			if patcher.KubeCluster == nil {
				patchee.KubeCluster = nil
				continue
			}
			if patchee.KubeCluster == nil {
				patchee.KubeCluster = &KubeCluster{}
			}
			if o, err := DefaultApplyFieldMaskKubeCluster(ctx, patchee.KubeCluster, patcher.KubeCluster, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"KubeCluster.", db); err != nil {
				return nil, err
			} else {
				patchee.KubeCluster = o
			}
			continue
		}
		if f == prefix+"KubeCluster" {
			updatedKubeCluster = true
			patchee.KubeCluster = patcher.KubeCluster
			continue
		}
		if f == prefix+"KubeClusterId" {
			patchee.KubeClusterId = patcher.KubeClusterId
			continue
		}
		if f == prefix+"ApplicationInstanceId" {
			patchee.ApplicationInstanceId = patcher.ApplicationInstanceId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDeployment executes a gorm list call
func DefaultListDeployment(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Deployment, error) {
	in := Deployment{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &DeploymentORM{}, &Deployment{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []DeploymentORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeploymentORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Deployment{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DeploymentORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type DeploymentORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type DeploymentORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]DeploymentORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}
type CloudProvidersDefaultServer struct {
}

// Create ...
func (m *CloudProvidersDefaultServer) Create(ctx context.Context, in *CreateCloudProviderRequest) (*CreateCloudProviderResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(CloudProvidersCloudProviderWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateCloudProvider(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateCloudProviderResponse{Result: res}
	if custom, ok := interface{}(in).(CloudProvidersCloudProviderWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// CloudProvidersCloudProviderWithBeforeCreate called before DefaultCreateCloudProvider in the default Create handler
type CloudProvidersCloudProviderWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// CloudProvidersCloudProviderWithAfterCreate called before DefaultCreateCloudProvider in the default Create handler
type CloudProvidersCloudProviderWithAfterCreate interface {
	AfterCreate(context.Context, *CreateCloudProviderResponse, *gorm1.DB) error
}

// Read ...
func (m *CloudProvidersDefaultServer) Read(ctx context.Context, in *ReadCloudProviderRequest) (*ReadCloudProviderResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(CloudProvidersCloudProviderWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadCloudProvider(ctx, &CloudProvider{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadCloudProviderResponse{Result: res}
	if custom, ok := interface{}(in).(CloudProvidersCloudProviderWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// CloudProvidersCloudProviderWithBeforeRead called before DefaultReadCloudProvider in the default Read handler
type CloudProvidersCloudProviderWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// CloudProvidersCloudProviderWithAfterRead called before DefaultReadCloudProvider in the default Read handler
type CloudProvidersCloudProviderWithAfterRead interface {
	AfterRead(context.Context, *ReadCloudProviderResponse, *gorm1.DB) error
}

// Update ...
func (m *CloudProvidersDefaultServer) Update(ctx context.Context, in *UpdateCloudProviderRequest) (*UpdateCloudProviderResponse, error) {
	var err error
	var res *CloudProvider
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(CloudProvidersCloudProviderWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateCloudProvider(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchCloudProvider(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateCloudProviderResponse{Result: res}
	if custom, ok := interface{}(in).(CloudProvidersCloudProviderWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// CloudProvidersCloudProviderWithBeforeUpdate called before DefaultUpdateCloudProvider in the default Update handler
type CloudProvidersCloudProviderWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// CloudProvidersCloudProviderWithAfterUpdate called before DefaultUpdateCloudProvider in the default Update handler
type CloudProvidersCloudProviderWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateCloudProviderResponse, *gorm1.DB) error
}

// Delete ...
func (m *CloudProvidersDefaultServer) Delete(ctx context.Context, in *DeleteCloudProviderRequest) (*DeleteCloudProviderResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(CloudProvidersCloudProviderWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteCloudProvider(ctx, &CloudProvider{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteCloudProviderResponse{}
	if custom, ok := interface{}(in).(CloudProvidersCloudProviderWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// CloudProvidersCloudProviderWithBeforeDelete called before DefaultDeleteCloudProvider in the default Delete handler
type CloudProvidersCloudProviderWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// CloudProvidersCloudProviderWithAfterDelete called before DefaultDeleteCloudProvider in the default Delete handler
type CloudProvidersCloudProviderWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteCloudProviderResponse, *gorm1.DB) error
}

// List ...
func (m *CloudProvidersDefaultServer) List(ctx context.Context, in *ListCloudProviderRequest) (*ListCloudProvidersResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(CloudProvidersCloudProviderWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListCloudProvider(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListCloudProvidersResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(CloudProvidersCloudProviderWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// CloudProvidersCloudProviderWithBeforeList called before DefaultListCloudProvider in the default List handler
type CloudProvidersCloudProviderWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// CloudProvidersCloudProviderWithAfterList called before DefaultListCloudProvider in the default List handler
type CloudProvidersCloudProviderWithAfterList interface {
	AfterList(context.Context, *ListCloudProvidersResponse, *gorm1.DB) error
}
type RegionsDefaultServer struct {
}

// Create ...
func (m *RegionsDefaultServer) Create(ctx context.Context, in *CreateRegionRequest) (*CreateRegionResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(RegionsRegionWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateRegion(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateRegionResponse{Result: res}
	if custom, ok := interface{}(in).(RegionsRegionWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// RegionsRegionWithBeforeCreate called before DefaultCreateRegion in the default Create handler
type RegionsRegionWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// RegionsRegionWithAfterCreate called before DefaultCreateRegion in the default Create handler
type RegionsRegionWithAfterCreate interface {
	AfterCreate(context.Context, *CreateRegionResponse, *gorm1.DB) error
}

// Read ...
func (m *RegionsDefaultServer) Read(ctx context.Context, in *ReadRegionRequest) (*ReadRegionResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(RegionsRegionWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadRegion(ctx, &Region{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadRegionResponse{Result: res}
	if custom, ok := interface{}(in).(RegionsRegionWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// RegionsRegionWithBeforeRead called before DefaultReadRegion in the default Read handler
type RegionsRegionWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// RegionsRegionWithAfterRead called before DefaultReadRegion in the default Read handler
type RegionsRegionWithAfterRead interface {
	AfterRead(context.Context, *ReadRegionResponse, *gorm1.DB) error
}

// Update ...
func (m *RegionsDefaultServer) Update(ctx context.Context, in *UpdateRegionRequest) (*UpdateRegionResponse, error) {
	var err error
	var res *Region
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(RegionsRegionWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateRegion(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchRegion(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateRegionResponse{Result: res}
	if custom, ok := interface{}(in).(RegionsRegionWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// RegionsRegionWithBeforeUpdate called before DefaultUpdateRegion in the default Update handler
type RegionsRegionWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// RegionsRegionWithAfterUpdate called before DefaultUpdateRegion in the default Update handler
type RegionsRegionWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateRegionResponse, *gorm1.DB) error
}

// Delete ...
func (m *RegionsDefaultServer) Delete(ctx context.Context, in *DeleteRegionRequest) (*DeleteRegionResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(RegionsRegionWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteRegion(ctx, &Region{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteRegionResponse{}
	if custom, ok := interface{}(in).(RegionsRegionWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// RegionsRegionWithBeforeDelete called before DefaultDeleteRegion in the default Delete handler
type RegionsRegionWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// RegionsRegionWithAfterDelete called before DefaultDeleteRegion in the default Delete handler
type RegionsRegionWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteRegionResponse, *gorm1.DB) error
}

// List ...
func (m *RegionsDefaultServer) List(ctx context.Context, in *ListRegionRequest) (*ListRegionsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(RegionsRegionWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListRegion(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListRegionsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(RegionsRegionWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// RegionsRegionWithBeforeList called before DefaultListRegion in the default List handler
type RegionsRegionWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// RegionsRegionWithAfterList called before DefaultListRegion in the default List handler
type RegionsRegionWithAfterList interface {
	AfterList(context.Context, *ListRegionsResponse, *gorm1.DB) error
}
type NetworksDefaultServer struct {
}

// Create ...
func (m *NetworksDefaultServer) Create(ctx context.Context, in *CreateNetworkRequest) (*CreateNetworkResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(NetworksNetworkWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateNetwork(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateNetworkResponse{Result: res}
	if custom, ok := interface{}(in).(NetworksNetworkWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// NetworksNetworkWithBeforeCreate called before DefaultCreateNetwork in the default Create handler
type NetworksNetworkWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// NetworksNetworkWithAfterCreate called before DefaultCreateNetwork in the default Create handler
type NetworksNetworkWithAfterCreate interface {
	AfterCreate(context.Context, *CreateNetworkResponse, *gorm1.DB) error
}

// Read ...
func (m *NetworksDefaultServer) Read(ctx context.Context, in *ReadNetworkRequest) (*ReadNetworkResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(NetworksNetworkWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadNetwork(ctx, &Network{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadNetworkResponse{Result: res}
	if custom, ok := interface{}(in).(NetworksNetworkWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// NetworksNetworkWithBeforeRead called before DefaultReadNetwork in the default Read handler
type NetworksNetworkWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// NetworksNetworkWithAfterRead called before DefaultReadNetwork in the default Read handler
type NetworksNetworkWithAfterRead interface {
	AfterRead(context.Context, *ReadNetworkResponse, *gorm1.DB) error
}

// Update ...
func (m *NetworksDefaultServer) Update(ctx context.Context, in *UpdateNetworkRequest) (*UpdateNetworkResponse, error) {
	var err error
	var res *Network
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(NetworksNetworkWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateNetwork(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchNetwork(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateNetworkResponse{Result: res}
	if custom, ok := interface{}(in).(NetworksNetworkWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// NetworksNetworkWithBeforeUpdate called before DefaultUpdateNetwork in the default Update handler
type NetworksNetworkWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// NetworksNetworkWithAfterUpdate called before DefaultUpdateNetwork in the default Update handler
type NetworksNetworkWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateNetworkResponse, *gorm1.DB) error
}

// Delete ...
func (m *NetworksDefaultServer) Delete(ctx context.Context, in *DeleteNetworkRequest) (*DeleteNetworkResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(NetworksNetworkWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteNetwork(ctx, &Network{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteNetworkResponse{}
	if custom, ok := interface{}(in).(NetworksNetworkWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// NetworksNetworkWithBeforeDelete called before DefaultDeleteNetwork in the default Delete handler
type NetworksNetworkWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// NetworksNetworkWithAfterDelete called before DefaultDeleteNetwork in the default Delete handler
type NetworksNetworkWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteNetworkResponse, *gorm1.DB) error
}

// List ...
func (m *NetworksDefaultServer) List(ctx context.Context, in *ListNetworkRequest) (*ListNetworksResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(NetworksNetworkWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListNetwork(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListNetworksResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(NetworksNetworkWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// NetworksNetworkWithBeforeList called before DefaultListNetwork in the default List handler
type NetworksNetworkWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// NetworksNetworkWithAfterList called before DefaultListNetwork in the default List handler
type NetworksNetworkWithAfterList interface {
	AfterList(context.Context, *ListNetworksResponse, *gorm1.DB) error
}
type LifecyclesDefaultServer struct {
}

// Create ...
func (m *LifecyclesDefaultServer) Create(ctx context.Context, in *CreateLifecycleRequest) (*CreateLifecycleResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(LifecyclesLifecycleWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateLifecycle(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateLifecycleResponse{Result: res}
	if custom, ok := interface{}(in).(LifecyclesLifecycleWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// LifecyclesLifecycleWithBeforeCreate called before DefaultCreateLifecycle in the default Create handler
type LifecyclesLifecycleWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// LifecyclesLifecycleWithAfterCreate called before DefaultCreateLifecycle in the default Create handler
type LifecyclesLifecycleWithAfterCreate interface {
	AfterCreate(context.Context, *CreateLifecycleResponse, *gorm1.DB) error
}

// Read ...
func (m *LifecyclesDefaultServer) Read(ctx context.Context, in *ReadLifecycleRequest) (*ReadLifecycleResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(LifecyclesLifecycleWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadLifecycle(ctx, &Lifecycle{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadLifecycleResponse{Result: res}
	if custom, ok := interface{}(in).(LifecyclesLifecycleWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// LifecyclesLifecycleWithBeforeRead called before DefaultReadLifecycle in the default Read handler
type LifecyclesLifecycleWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// LifecyclesLifecycleWithAfterRead called before DefaultReadLifecycle in the default Read handler
type LifecyclesLifecycleWithAfterRead interface {
	AfterRead(context.Context, *ReadLifecycleResponse, *gorm1.DB) error
}

// Update ...
func (m *LifecyclesDefaultServer) Update(ctx context.Context, in *UpdateLifecycleRequest) (*UpdateLifecycleResponse, error) {
	var err error
	var res *Lifecycle
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(LifecyclesLifecycleWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateLifecycle(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchLifecycle(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateLifecycleResponse{Result: res}
	if custom, ok := interface{}(in).(LifecyclesLifecycleWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// LifecyclesLifecycleWithBeforeUpdate called before DefaultUpdateLifecycle in the default Update handler
type LifecyclesLifecycleWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// LifecyclesLifecycleWithAfterUpdate called before DefaultUpdateLifecycle in the default Update handler
type LifecyclesLifecycleWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateLifecycleResponse, *gorm1.DB) error
}

// Delete ...
func (m *LifecyclesDefaultServer) Delete(ctx context.Context, in *DeleteLifecycleRequest) (*DeleteLifecycleResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(LifecyclesLifecycleWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteLifecycle(ctx, &Lifecycle{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteLifecycleResponse{}
	if custom, ok := interface{}(in).(LifecyclesLifecycleWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// LifecyclesLifecycleWithBeforeDelete called before DefaultDeleteLifecycle in the default Delete handler
type LifecyclesLifecycleWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// LifecyclesLifecycleWithAfterDelete called before DefaultDeleteLifecycle in the default Delete handler
type LifecyclesLifecycleWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteLifecycleResponse, *gorm1.DB) error
}

// List ...
func (m *LifecyclesDefaultServer) List(ctx context.Context, in *ListLifecycleRequest) (*ListLifecyclesResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(LifecyclesLifecycleWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListLifecycle(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListLifecyclesResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(LifecyclesLifecycleWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// LifecyclesLifecycleWithBeforeList called before DefaultListLifecycle in the default List handler
type LifecyclesLifecycleWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// LifecyclesLifecycleWithAfterList called before DefaultListLifecycle in the default List handler
type LifecyclesLifecycleWithAfterList interface {
	AfterList(context.Context, *ListLifecyclesResponse, *gorm1.DB) error
}
type ChartVersionsDefaultServer struct {
}

// Create ...
func (m *ChartVersionsDefaultServer) Create(ctx context.Context, in *CreateChartVersionRequest) (*CreateChartVersionResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ChartVersionsChartVersionWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateChartVersion(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateChartVersionResponse{Result: res}
	if custom, ok := interface{}(in).(ChartVersionsChartVersionWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ChartVersionsChartVersionWithBeforeCreate called before DefaultCreateChartVersion in the default Create handler
type ChartVersionsChartVersionWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ChartVersionsChartVersionWithAfterCreate called before DefaultCreateChartVersion in the default Create handler
type ChartVersionsChartVersionWithAfterCreate interface {
	AfterCreate(context.Context, *CreateChartVersionResponse, *gorm1.DB) error
}

// Read ...
func (m *ChartVersionsDefaultServer) Read(ctx context.Context, in *ReadChartVersionRequest) (*ReadChartVersionResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ChartVersionsChartVersionWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadChartVersion(ctx, &ChartVersion{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadChartVersionResponse{Result: res}
	if custom, ok := interface{}(in).(ChartVersionsChartVersionWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ChartVersionsChartVersionWithBeforeRead called before DefaultReadChartVersion in the default Read handler
type ChartVersionsChartVersionWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ChartVersionsChartVersionWithAfterRead called before DefaultReadChartVersion in the default Read handler
type ChartVersionsChartVersionWithAfterRead interface {
	AfterRead(context.Context, *ReadChartVersionResponse, *gorm1.DB) error
}

// Update ...
func (m *ChartVersionsDefaultServer) Update(ctx context.Context, in *UpdateChartVersionRequest) (*UpdateChartVersionResponse, error) {
	var err error
	var res *ChartVersion
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ChartVersionsChartVersionWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateChartVersion(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchChartVersion(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateChartVersionResponse{Result: res}
	if custom, ok := interface{}(in).(ChartVersionsChartVersionWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ChartVersionsChartVersionWithBeforeUpdate called before DefaultUpdateChartVersion in the default Update handler
type ChartVersionsChartVersionWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ChartVersionsChartVersionWithAfterUpdate called before DefaultUpdateChartVersion in the default Update handler
type ChartVersionsChartVersionWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateChartVersionResponse, *gorm1.DB) error
}

// Delete ...
func (m *ChartVersionsDefaultServer) Delete(ctx context.Context, in *DeleteChartVersionRequest) (*DeleteChartVersionResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ChartVersionsChartVersionWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteChartVersion(ctx, &ChartVersion{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteChartVersionResponse{}
	if custom, ok := interface{}(in).(ChartVersionsChartVersionWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ChartVersionsChartVersionWithBeforeDelete called before DefaultDeleteChartVersion in the default Delete handler
type ChartVersionsChartVersionWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ChartVersionsChartVersionWithAfterDelete called before DefaultDeleteChartVersion in the default Delete handler
type ChartVersionsChartVersionWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteChartVersionResponse, *gorm1.DB) error
}

// List ...
func (m *ChartVersionsDefaultServer) List(ctx context.Context, in *ListChartVersionRequest) (*ListChartVersionsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ChartVersionsChartVersionWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListChartVersion(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListChartVersionsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(ChartVersionsChartVersionWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ChartVersionsChartVersionWithBeforeList called before DefaultListChartVersion in the default List handler
type ChartVersionsChartVersionWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ChartVersionsChartVersionWithAfterList called before DefaultListChartVersion in the default List handler
type ChartVersionsChartVersionWithAfterList interface {
	AfterList(context.Context, *ListChartVersionsResponse, *gorm1.DB) error
}
type AppConfigsDefaultServer struct {
}

// Create ...
func (m *AppConfigsDefaultServer) Create(ctx context.Context, in *CreateAppConfigRequest) (*CreateAppConfigResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AppConfigsAppConfigWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateAppConfig(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateAppConfigResponse{Result: res}
	if custom, ok := interface{}(in).(AppConfigsAppConfigWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AppConfigsAppConfigWithBeforeCreate called before DefaultCreateAppConfig in the default Create handler
type AppConfigsAppConfigWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AppConfigsAppConfigWithAfterCreate called before DefaultCreateAppConfig in the default Create handler
type AppConfigsAppConfigWithAfterCreate interface {
	AfterCreate(context.Context, *CreateAppConfigResponse, *gorm1.DB) error
}

// Read ...
func (m *AppConfigsDefaultServer) Read(ctx context.Context, in *ReadAppConfigRequest) (*ReadAppConfigResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AppConfigsAppConfigWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadAppConfig(ctx, &AppConfig{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadAppConfigResponse{Result: res}
	if custom, ok := interface{}(in).(AppConfigsAppConfigWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AppConfigsAppConfigWithBeforeRead called before DefaultReadAppConfig in the default Read handler
type AppConfigsAppConfigWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AppConfigsAppConfigWithAfterRead called before DefaultReadAppConfig in the default Read handler
type AppConfigsAppConfigWithAfterRead interface {
	AfterRead(context.Context, *ReadAppConfigResponse, *gorm1.DB) error
}

// Update ...
func (m *AppConfigsDefaultServer) Update(ctx context.Context, in *UpdateAppConfigRequest) (*UpdateAppConfigResponse, error) {
	var err error
	var res *AppConfig
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AppConfigsAppConfigWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateAppConfig(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchAppConfig(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateAppConfigResponse{Result: res}
	if custom, ok := interface{}(in).(AppConfigsAppConfigWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AppConfigsAppConfigWithBeforeUpdate called before DefaultUpdateAppConfig in the default Update handler
type AppConfigsAppConfigWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AppConfigsAppConfigWithAfterUpdate called before DefaultUpdateAppConfig in the default Update handler
type AppConfigsAppConfigWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateAppConfigResponse, *gorm1.DB) error
}

// Delete ...
func (m *AppConfigsDefaultServer) Delete(ctx context.Context, in *DeleteAppConfigRequest) (*DeleteAppConfigResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AppConfigsAppConfigWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteAppConfig(ctx, &AppConfig{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteAppConfigResponse{}
	if custom, ok := interface{}(in).(AppConfigsAppConfigWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AppConfigsAppConfigWithBeforeDelete called before DefaultDeleteAppConfig in the default Delete handler
type AppConfigsAppConfigWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AppConfigsAppConfigWithAfterDelete called before DefaultDeleteAppConfig in the default Delete handler
type AppConfigsAppConfigWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteAppConfigResponse, *gorm1.DB) error
}

// List ...
func (m *AppConfigsDefaultServer) List(ctx context.Context, in *ListAppConfigRequest) (*ListAppConfigsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AppConfigsAppConfigWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListAppConfig(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListAppConfigsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(AppConfigsAppConfigWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AppConfigsAppConfigWithBeforeList called before DefaultListAppConfig in the default List handler
type AppConfigsAppConfigWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AppConfigsAppConfigWithAfterList called before DefaultListAppConfig in the default List handler
type AppConfigsAppConfigWithAfterList interface {
	AfterList(context.Context, *ListAppConfigsResponse, *gorm1.DB) error
}
type EnvironmentsDefaultServer struct {
}

// Create ...
func (m *EnvironmentsDefaultServer) Create(ctx context.Context, in *CreateEnvironmentRequest) (*CreateEnvironmentResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(EnvironmentsEnvironmentWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateEnvironment(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateEnvironmentResponse{Result: res}
	if custom, ok := interface{}(in).(EnvironmentsEnvironmentWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// EnvironmentsEnvironmentWithBeforeCreate called before DefaultCreateEnvironment in the default Create handler
type EnvironmentsEnvironmentWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// EnvironmentsEnvironmentWithAfterCreate called before DefaultCreateEnvironment in the default Create handler
type EnvironmentsEnvironmentWithAfterCreate interface {
	AfterCreate(context.Context, *CreateEnvironmentResponse, *gorm1.DB) error
}

// Read ...
func (m *EnvironmentsDefaultServer) Read(ctx context.Context, in *ReadEnvironmentRequest) (*ReadEnvironmentResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(EnvironmentsEnvironmentWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadEnvironment(ctx, &Environment{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadEnvironmentResponse{Result: res}
	if custom, ok := interface{}(in).(EnvironmentsEnvironmentWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// EnvironmentsEnvironmentWithBeforeRead called before DefaultReadEnvironment in the default Read handler
type EnvironmentsEnvironmentWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// EnvironmentsEnvironmentWithAfterRead called before DefaultReadEnvironment in the default Read handler
type EnvironmentsEnvironmentWithAfterRead interface {
	AfterRead(context.Context, *ReadEnvironmentResponse, *gorm1.DB) error
}

// Update ...
func (m *EnvironmentsDefaultServer) Update(ctx context.Context, in *UpdateEnvironmentRequest) (*UpdateEnvironmentResponse, error) {
	var err error
	var res *Environment
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(EnvironmentsEnvironmentWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateEnvironment(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchEnvironment(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateEnvironmentResponse{Result: res}
	if custom, ok := interface{}(in).(EnvironmentsEnvironmentWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// EnvironmentsEnvironmentWithBeforeUpdate called before DefaultUpdateEnvironment in the default Update handler
type EnvironmentsEnvironmentWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// EnvironmentsEnvironmentWithAfterUpdate called before DefaultUpdateEnvironment in the default Update handler
type EnvironmentsEnvironmentWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateEnvironmentResponse, *gorm1.DB) error
}

// Delete ...
func (m *EnvironmentsDefaultServer) Delete(ctx context.Context, in *DeleteEnvironmentRequest) (*DeleteEnvironmentResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(EnvironmentsEnvironmentWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteEnvironment(ctx, &Environment{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteEnvironmentResponse{}
	if custom, ok := interface{}(in).(EnvironmentsEnvironmentWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// EnvironmentsEnvironmentWithBeforeDelete called before DefaultDeleteEnvironment in the default Delete handler
type EnvironmentsEnvironmentWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// EnvironmentsEnvironmentWithAfterDelete called before DefaultDeleteEnvironment in the default Delete handler
type EnvironmentsEnvironmentWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteEnvironmentResponse, *gorm1.DB) error
}

// List ...
func (m *EnvironmentsDefaultServer) List(ctx context.Context, in *ListEnvironmentRequest) (*ListEnvironmentsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(EnvironmentsEnvironmentWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListEnvironment(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListEnvironmentsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(EnvironmentsEnvironmentWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// EnvironmentsEnvironmentWithBeforeList called before DefaultListEnvironment in the default List handler
type EnvironmentsEnvironmentWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// EnvironmentsEnvironmentWithAfterList called before DefaultListEnvironment in the default List handler
type EnvironmentsEnvironmentWithAfterList interface {
	AfterList(context.Context, *ListEnvironmentsResponse, *gorm1.DB) error
}
type ApplicationsDefaultServer struct {
}

// Create ...
func (m *ApplicationsDefaultServer) Create(ctx context.Context, in *CreateApplicationRequest) (*CreateApplicationResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateApplication(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateApplicationResponse{Result: res}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationsApplicationWithBeforeCreate called before DefaultCreateApplication in the default Create handler
type ApplicationsApplicationWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationsApplicationWithAfterCreate called before DefaultCreateApplication in the default Create handler
type ApplicationsApplicationWithAfterCreate interface {
	AfterCreate(context.Context, *CreateApplicationResponse, *gorm1.DB) error
}

// Read ...
func (m *ApplicationsDefaultServer) Read(ctx context.Context, in *ReadApplicationRequest) (*ReadApplicationResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadApplication(ctx, &Application{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadApplicationResponse{Result: res}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationsApplicationWithBeforeRead called before DefaultReadApplication in the default Read handler
type ApplicationsApplicationWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationsApplicationWithAfterRead called before DefaultReadApplication in the default Read handler
type ApplicationsApplicationWithAfterRead interface {
	AfterRead(context.Context, *ReadApplicationResponse, *gorm1.DB) error
}

// Update ...
func (m *ApplicationsDefaultServer) Update(ctx context.Context, in *UpdateApplicationRequest) (*UpdateApplicationResponse, error) {
	var err error
	var res *Application
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateApplication(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchApplication(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateApplicationResponse{Result: res}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationsApplicationWithBeforeUpdate called before DefaultUpdateApplication in the default Update handler
type ApplicationsApplicationWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationsApplicationWithAfterUpdate called before DefaultUpdateApplication in the default Update handler
type ApplicationsApplicationWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateApplicationResponse, *gorm1.DB) error
}

// Delete ...
func (m *ApplicationsDefaultServer) Delete(ctx context.Context, in *DeleteApplicationRequest) (*DeleteApplicationResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteApplication(ctx, &Application{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteApplicationResponse{}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationsApplicationWithBeforeDelete called before DefaultDeleteApplication in the default Delete handler
type ApplicationsApplicationWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationsApplicationWithAfterDelete called before DefaultDeleteApplication in the default Delete handler
type ApplicationsApplicationWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteApplicationResponse, *gorm1.DB) error
}

// List ...
func (m *ApplicationsDefaultServer) List(ctx context.Context, in *ListApplicationRequest) (*ListApplicationsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListApplication(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListApplicationsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(ApplicationsApplicationWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationsApplicationWithBeforeList called before DefaultListApplication in the default List handler
type ApplicationsApplicationWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationsApplicationWithAfterList called before DefaultListApplication in the default List handler
type ApplicationsApplicationWithAfterList interface {
	AfterList(context.Context, *ListApplicationsResponse, *gorm1.DB) error
}
type AppVersionsDefaultServer struct {
}

// Create ...
func (m *AppVersionsDefaultServer) Create(ctx context.Context, in *CreateAppVersionRequest) (*CreateAppVersionResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AppVersionsAppVersionWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateAppVersion(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateAppVersionResponse{Result: res}
	if custom, ok := interface{}(in).(AppVersionsAppVersionWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AppVersionsAppVersionWithBeforeCreate called before DefaultCreateAppVersion in the default Create handler
type AppVersionsAppVersionWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AppVersionsAppVersionWithAfterCreate called before DefaultCreateAppVersion in the default Create handler
type AppVersionsAppVersionWithAfterCreate interface {
	AfterCreate(context.Context, *CreateAppVersionResponse, *gorm1.DB) error
}

// Read ...
func (m *AppVersionsDefaultServer) Read(ctx context.Context, in *ReadAppVersionRequest) (*ReadAppVersionResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AppVersionsAppVersionWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadAppVersion(ctx, &AppVersion{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadAppVersionResponse{Result: res}
	if custom, ok := interface{}(in).(AppVersionsAppVersionWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AppVersionsAppVersionWithBeforeRead called before DefaultReadAppVersion in the default Read handler
type AppVersionsAppVersionWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AppVersionsAppVersionWithAfterRead called before DefaultReadAppVersion in the default Read handler
type AppVersionsAppVersionWithAfterRead interface {
	AfterRead(context.Context, *ReadAppVersionResponse, *gorm1.DB) error
}

// Update ...
func (m *AppVersionsDefaultServer) Update(ctx context.Context, in *UpdateAppVersionRequest) (*UpdateAppVersionResponse, error) {
	var err error
	var res *AppVersion
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AppVersionsAppVersionWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateAppVersion(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchAppVersion(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateAppVersionResponse{Result: res}
	if custom, ok := interface{}(in).(AppVersionsAppVersionWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AppVersionsAppVersionWithBeforeUpdate called before DefaultUpdateAppVersion in the default Update handler
type AppVersionsAppVersionWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AppVersionsAppVersionWithAfterUpdate called before DefaultUpdateAppVersion in the default Update handler
type AppVersionsAppVersionWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateAppVersionResponse, *gorm1.DB) error
}

// Delete ...
func (m *AppVersionsDefaultServer) Delete(ctx context.Context, in *DeleteAppVersionRequest) (*DeleteAppVersionResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AppVersionsAppVersionWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteAppVersion(ctx, &AppVersion{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteAppVersionResponse{}
	if custom, ok := interface{}(in).(AppVersionsAppVersionWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AppVersionsAppVersionWithBeforeDelete called before DefaultDeleteAppVersion in the default Delete handler
type AppVersionsAppVersionWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AppVersionsAppVersionWithAfterDelete called before DefaultDeleteAppVersion in the default Delete handler
type AppVersionsAppVersionWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteAppVersionResponse, *gorm1.DB) error
}

// List ...
func (m *AppVersionsDefaultServer) List(ctx context.Context, in *ListAppVersionRequest) (*ListAppVersionsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(AppVersionsAppVersionWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListAppVersion(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListAppVersionsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(AppVersionsAppVersionWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// AppVersionsAppVersionWithBeforeList called before DefaultListAppVersion in the default List handler
type AppVersionsAppVersionWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// AppVersionsAppVersionWithAfterList called before DefaultListAppVersion in the default List handler
type AppVersionsAppVersionWithAfterList interface {
	AfterList(context.Context, *ListAppVersionsResponse, *gorm1.DB) error
}
type ApplicationInstancesDefaultServer struct {
}

// Create ...
func (m *ApplicationInstancesDefaultServer) Create(ctx context.Context, in *CreateApplicationInstanceRequest) (*CreateApplicationInstanceResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationInstancesApplicationInstanceWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateApplicationInstance(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateApplicationInstanceResponse{Result: res}
	if custom, ok := interface{}(in).(ApplicationInstancesApplicationInstanceWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationInstancesApplicationInstanceWithBeforeCreate called before DefaultCreateApplicationInstance in the default Create handler
type ApplicationInstancesApplicationInstanceWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationInstancesApplicationInstanceWithAfterCreate called before DefaultCreateApplicationInstance in the default Create handler
type ApplicationInstancesApplicationInstanceWithAfterCreate interface {
	AfterCreate(context.Context, *CreateApplicationInstanceResponse, *gorm1.DB) error
}

// Read ...
func (m *ApplicationInstancesDefaultServer) Read(ctx context.Context, in *ReadApplicationInstanceRequest) (*ReadApplicationInstanceResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationInstancesApplicationInstanceWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadApplicationInstance(ctx, &ApplicationInstance{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadApplicationInstanceResponse{Result: res}
	if custom, ok := interface{}(in).(ApplicationInstancesApplicationInstanceWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationInstancesApplicationInstanceWithBeforeRead called before DefaultReadApplicationInstance in the default Read handler
type ApplicationInstancesApplicationInstanceWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationInstancesApplicationInstanceWithAfterRead called before DefaultReadApplicationInstance in the default Read handler
type ApplicationInstancesApplicationInstanceWithAfterRead interface {
	AfterRead(context.Context, *ReadApplicationInstanceResponse, *gorm1.DB) error
}

// Update ...
func (m *ApplicationInstancesDefaultServer) Update(ctx context.Context, in *UpdateApplicationInstanceRequest) (*UpdateApplicationInstanceResponse, error) {
	var err error
	var res *ApplicationInstance
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationInstancesApplicationInstanceWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateApplicationInstance(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchApplicationInstance(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateApplicationInstanceResponse{Result: res}
	if custom, ok := interface{}(in).(ApplicationInstancesApplicationInstanceWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationInstancesApplicationInstanceWithBeforeUpdate called before DefaultUpdateApplicationInstance in the default Update handler
type ApplicationInstancesApplicationInstanceWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationInstancesApplicationInstanceWithAfterUpdate called before DefaultUpdateApplicationInstance in the default Update handler
type ApplicationInstancesApplicationInstanceWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateApplicationInstanceResponse, *gorm1.DB) error
}

// Delete ...
func (m *ApplicationInstancesDefaultServer) Delete(ctx context.Context, in *DeleteApplicationInstanceRequest) (*DeleteApplicationInstanceResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationInstancesApplicationInstanceWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteApplicationInstance(ctx, &ApplicationInstance{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteApplicationInstanceResponse{}
	if custom, ok := interface{}(in).(ApplicationInstancesApplicationInstanceWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationInstancesApplicationInstanceWithBeforeDelete called before DefaultDeleteApplicationInstance in the default Delete handler
type ApplicationInstancesApplicationInstanceWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationInstancesApplicationInstanceWithAfterDelete called before DefaultDeleteApplicationInstance in the default Delete handler
type ApplicationInstancesApplicationInstanceWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteApplicationInstanceResponse, *gorm1.DB) error
}

// List ...
func (m *ApplicationInstancesDefaultServer) List(ctx context.Context, in *ListApplicationInstanceRequest) (*ListApplicationInstancesResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ApplicationInstancesApplicationInstanceWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListApplicationInstance(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListApplicationInstancesResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(ApplicationInstancesApplicationInstanceWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ApplicationInstancesApplicationInstanceWithBeforeList called before DefaultListApplicationInstance in the default List handler
type ApplicationInstancesApplicationInstanceWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ApplicationInstancesApplicationInstanceWithAfterList called before DefaultListApplicationInstance in the default List handler
type ApplicationInstancesApplicationInstanceWithAfterList interface {
	AfterList(context.Context, *ListApplicationInstancesResponse, *gorm1.DB) error
}
type VaultsDefaultServer struct {
}

// Create ...
func (m *VaultsDefaultServer) Create(ctx context.Context, in *CreateVaultRequest) (*CreateVaultResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VaultsVaultWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateVault(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateVaultResponse{Result: res}
	if custom, ok := interface{}(in).(VaultsVaultWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VaultsVaultWithBeforeCreate called before DefaultCreateVault in the default Create handler
type VaultsVaultWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VaultsVaultWithAfterCreate called before DefaultCreateVault in the default Create handler
type VaultsVaultWithAfterCreate interface {
	AfterCreate(context.Context, *CreateVaultResponse, *gorm1.DB) error
}

// Read ...
func (m *VaultsDefaultServer) Read(ctx context.Context, in *ReadVaultRequest) (*ReadVaultResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VaultsVaultWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadVault(ctx, &Vault{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadVaultResponse{Result: res}
	if custom, ok := interface{}(in).(VaultsVaultWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VaultsVaultWithBeforeRead called before DefaultReadVault in the default Read handler
type VaultsVaultWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VaultsVaultWithAfterRead called before DefaultReadVault in the default Read handler
type VaultsVaultWithAfterRead interface {
	AfterRead(context.Context, *ReadVaultResponse, *gorm1.DB) error
}

// Update ...
func (m *VaultsDefaultServer) Update(ctx context.Context, in *UpdateVaultRequest) (*UpdateVaultResponse, error) {
	var err error
	var res *Vault
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VaultsVaultWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateVault(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchVault(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateVaultResponse{Result: res}
	if custom, ok := interface{}(in).(VaultsVaultWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VaultsVaultWithBeforeUpdate called before DefaultUpdateVault in the default Update handler
type VaultsVaultWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VaultsVaultWithAfterUpdate called before DefaultUpdateVault in the default Update handler
type VaultsVaultWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateVaultResponse, *gorm1.DB) error
}

// Delete ...
func (m *VaultsDefaultServer) Delete(ctx context.Context, in *DeleteVaultRequest) (*DeleteVaultResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VaultsVaultWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteVault(ctx, &Vault{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteVaultResponse{}
	if custom, ok := interface{}(in).(VaultsVaultWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VaultsVaultWithBeforeDelete called before DefaultDeleteVault in the default Delete handler
type VaultsVaultWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VaultsVaultWithAfterDelete called before DefaultDeleteVault in the default Delete handler
type VaultsVaultWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteVaultResponse, *gorm1.DB) error
}

// List ...
func (m *VaultsDefaultServer) List(ctx context.Context, in *ListVaultRequest) (*ListVaultsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(VaultsVaultWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListVault(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListVaultsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(VaultsVaultWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// VaultsVaultWithBeforeList called before DefaultListVault in the default List handler
type VaultsVaultWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// VaultsVaultWithAfterList called before DefaultListVault in the default List handler
type VaultsVaultWithAfterList interface {
	AfterList(context.Context, *ListVaultsResponse, *gorm1.DB) error
}
type SecretsDefaultServer struct {
}

// Create ...
func (m *SecretsDefaultServer) Create(ctx context.Context, in *CreateSecretRequest) (*CreateSecretResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(SecretsSecretWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateSecret(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateSecretResponse{Result: res}
	if custom, ok := interface{}(in).(SecretsSecretWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// SecretsSecretWithBeforeCreate called before DefaultCreateSecret in the default Create handler
type SecretsSecretWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// SecretsSecretWithAfterCreate called before DefaultCreateSecret in the default Create handler
type SecretsSecretWithAfterCreate interface {
	AfterCreate(context.Context, *CreateSecretResponse, *gorm1.DB) error
}

// Read ...
func (m *SecretsDefaultServer) Read(ctx context.Context, in *ReadSecretRequest) (*ReadSecretResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(SecretsSecretWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadSecret(ctx, &Secret{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadSecretResponse{Result: res}
	if custom, ok := interface{}(in).(SecretsSecretWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// SecretsSecretWithBeforeRead called before DefaultReadSecret in the default Read handler
type SecretsSecretWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// SecretsSecretWithAfterRead called before DefaultReadSecret in the default Read handler
type SecretsSecretWithAfterRead interface {
	AfterRead(context.Context, *ReadSecretResponse, *gorm1.DB) error
}

// Update ...
func (m *SecretsDefaultServer) Update(ctx context.Context, in *UpdateSecretRequest) (*UpdateSecretResponse, error) {
	var err error
	var res *Secret
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(SecretsSecretWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateSecret(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchSecret(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateSecretResponse{Result: res}
	if custom, ok := interface{}(in).(SecretsSecretWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// SecretsSecretWithBeforeUpdate called before DefaultUpdateSecret in the default Update handler
type SecretsSecretWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// SecretsSecretWithAfterUpdate called before DefaultUpdateSecret in the default Update handler
type SecretsSecretWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateSecretResponse, *gorm1.DB) error
}

// Delete ...
func (m *SecretsDefaultServer) Delete(ctx context.Context, in *DeleteSecretRequest) (*DeleteSecretResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(SecretsSecretWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteSecret(ctx, &Secret{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteSecretResponse{}
	if custom, ok := interface{}(in).(SecretsSecretWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// SecretsSecretWithBeforeDelete called before DefaultDeleteSecret in the default Delete handler
type SecretsSecretWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// SecretsSecretWithAfterDelete called before DefaultDeleteSecret in the default Delete handler
type SecretsSecretWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteSecretResponse, *gorm1.DB) error
}

// List ...
func (m *SecretsDefaultServer) List(ctx context.Context, in *ListSecretRequest) (*ListSecretsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(SecretsSecretWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListSecret(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListSecretsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(SecretsSecretWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// SecretsSecretWithBeforeList called before DefaultListSecret in the default List handler
type SecretsSecretWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// SecretsSecretWithAfterList called before DefaultListSecret in the default List handler
type SecretsSecretWithAfterList interface {
	AfterList(context.Context, *ListSecretsResponse, *gorm1.DB) error
}
type ArtifactsDefaultServer struct {
}

// Create ...
func (m *ArtifactsDefaultServer) Create(ctx context.Context, in *CreateArtifactRequest) (*CreateArtifactResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ArtifactsArtifactWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateArtifact(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateArtifactResponse{Result: res}
	if custom, ok := interface{}(in).(ArtifactsArtifactWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ArtifactsArtifactWithBeforeCreate called before DefaultCreateArtifact in the default Create handler
type ArtifactsArtifactWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ArtifactsArtifactWithAfterCreate called before DefaultCreateArtifact in the default Create handler
type ArtifactsArtifactWithAfterCreate interface {
	AfterCreate(context.Context, *CreateArtifactResponse, *gorm1.DB) error
}

// Read ...
func (m *ArtifactsDefaultServer) Read(ctx context.Context, in *ReadArtifactRequest) (*ReadArtifactResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ArtifactsArtifactWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadArtifact(ctx, &Artifact{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadArtifactResponse{Result: res}
	if custom, ok := interface{}(in).(ArtifactsArtifactWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ArtifactsArtifactWithBeforeRead called before DefaultReadArtifact in the default Read handler
type ArtifactsArtifactWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ArtifactsArtifactWithAfterRead called before DefaultReadArtifact in the default Read handler
type ArtifactsArtifactWithAfterRead interface {
	AfterRead(context.Context, *ReadArtifactResponse, *gorm1.DB) error
}

// Update ...
func (m *ArtifactsDefaultServer) Update(ctx context.Context, in *UpdateArtifactRequest) (*UpdateArtifactResponse, error) {
	var err error
	var res *Artifact
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ArtifactsArtifactWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateArtifact(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchArtifact(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateArtifactResponse{Result: res}
	if custom, ok := interface{}(in).(ArtifactsArtifactWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ArtifactsArtifactWithBeforeUpdate called before DefaultUpdateArtifact in the default Update handler
type ArtifactsArtifactWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ArtifactsArtifactWithAfterUpdate called before DefaultUpdateArtifact in the default Update handler
type ArtifactsArtifactWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateArtifactResponse, *gorm1.DB) error
}

// Delete ...
func (m *ArtifactsDefaultServer) Delete(ctx context.Context, in *DeleteArtifactRequest) (*DeleteArtifactResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ArtifactsArtifactWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteArtifact(ctx, &Artifact{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteArtifactResponse{}
	if custom, ok := interface{}(in).(ArtifactsArtifactWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ArtifactsArtifactWithBeforeDelete called before DefaultDeleteArtifact in the default Delete handler
type ArtifactsArtifactWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ArtifactsArtifactWithAfterDelete called before DefaultDeleteArtifact in the default Delete handler
type ArtifactsArtifactWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteArtifactResponse, *gorm1.DB) error
}

// List ...
func (m *ArtifactsDefaultServer) List(ctx context.Context, in *ListArtifactRequest) (*ListArtifactsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(ArtifactsArtifactWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListArtifact(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListArtifactsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(ArtifactsArtifactWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ArtifactsArtifactWithBeforeList called before DefaultListArtifact in the default List handler
type ArtifactsArtifactWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ArtifactsArtifactWithAfterList called before DefaultListArtifact in the default List handler
type ArtifactsArtifactWithAfterList interface {
	AfterList(context.Context, *ListArtifactsResponse, *gorm1.DB) error
}
type KubeClustersDefaultServer struct {
}

// Create ...
func (m *KubeClustersDefaultServer) Create(ctx context.Context, in *CreateKubeClusterRequest) (*CreateKubeClusterResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(KubeClustersKubeClusterWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateKubeCluster(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateKubeClusterResponse{Result: res}
	if custom, ok := interface{}(in).(KubeClustersKubeClusterWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// KubeClustersKubeClusterWithBeforeCreate called before DefaultCreateKubeCluster in the default Create handler
type KubeClustersKubeClusterWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// KubeClustersKubeClusterWithAfterCreate called before DefaultCreateKubeCluster in the default Create handler
type KubeClustersKubeClusterWithAfterCreate interface {
	AfterCreate(context.Context, *CreateKubeClusterResponse, *gorm1.DB) error
}

// Read ...
func (m *KubeClustersDefaultServer) Read(ctx context.Context, in *ReadKubeClusterRequest) (*ReadKubeClusterResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(KubeClustersKubeClusterWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadKubeCluster(ctx, &KubeCluster{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadKubeClusterResponse{Result: res}
	if custom, ok := interface{}(in).(KubeClustersKubeClusterWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// KubeClustersKubeClusterWithBeforeRead called before DefaultReadKubeCluster in the default Read handler
type KubeClustersKubeClusterWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// KubeClustersKubeClusterWithAfterRead called before DefaultReadKubeCluster in the default Read handler
type KubeClustersKubeClusterWithAfterRead interface {
	AfterRead(context.Context, *ReadKubeClusterResponse, *gorm1.DB) error
}

// Update ...
func (m *KubeClustersDefaultServer) Update(ctx context.Context, in *UpdateKubeClusterRequest) (*UpdateKubeClusterResponse, error) {
	var err error
	var res *KubeCluster
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(KubeClustersKubeClusterWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateKubeCluster(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchKubeCluster(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateKubeClusterResponse{Result: res}
	if custom, ok := interface{}(in).(KubeClustersKubeClusterWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// KubeClustersKubeClusterWithBeforeUpdate called before DefaultUpdateKubeCluster in the default Update handler
type KubeClustersKubeClusterWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// KubeClustersKubeClusterWithAfterUpdate called before DefaultUpdateKubeCluster in the default Update handler
type KubeClustersKubeClusterWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateKubeClusterResponse, *gorm1.DB) error
}

// Delete ...
func (m *KubeClustersDefaultServer) Delete(ctx context.Context, in *DeleteKubeClusterRequest) (*DeleteKubeClusterResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(KubeClustersKubeClusterWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteKubeCluster(ctx, &KubeCluster{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteKubeClusterResponse{}
	if custom, ok := interface{}(in).(KubeClustersKubeClusterWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// KubeClustersKubeClusterWithBeforeDelete called before DefaultDeleteKubeCluster in the default Delete handler
type KubeClustersKubeClusterWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// KubeClustersKubeClusterWithAfterDelete called before DefaultDeleteKubeCluster in the default Delete handler
type KubeClustersKubeClusterWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteKubeClusterResponse, *gorm1.DB) error
}

// List ...
func (m *KubeClustersDefaultServer) List(ctx context.Context, in *ListKubeClusterRequest) (*ListKubeClustersResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(KubeClustersKubeClusterWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListKubeCluster(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListKubeClustersResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(KubeClustersKubeClusterWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// KubeClustersKubeClusterWithBeforeList called before DefaultListKubeCluster in the default List handler
type KubeClustersKubeClusterWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// KubeClustersKubeClusterWithAfterList called before DefaultListKubeCluster in the default List handler
type KubeClustersKubeClusterWithAfterList interface {
	AfterList(context.Context, *ListKubeClustersResponse, *gorm1.DB) error
}
type DeploymentsDefaultServer struct {
}

// Create ...
func (m *DeploymentsDefaultServer) Create(ctx context.Context, in *CreateDeploymentRequest) (*CreateDeploymentResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(DeploymentsDeploymentWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateDeployment(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateDeploymentResponse{Result: res}
	if custom, ok := interface{}(in).(DeploymentsDeploymentWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// DeploymentsDeploymentWithBeforeCreate called before DefaultCreateDeployment in the default Create handler
type DeploymentsDeploymentWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// DeploymentsDeploymentWithAfterCreate called before DefaultCreateDeployment in the default Create handler
type DeploymentsDeploymentWithAfterCreate interface {
	AfterCreate(context.Context, *CreateDeploymentResponse, *gorm1.DB) error
}

// Read ...
func (m *DeploymentsDefaultServer) Read(ctx context.Context, in *ReadDeploymentRequest) (*ReadDeploymentResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(DeploymentsDeploymentWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadDeployment(ctx, &Deployment{Id: in.GetId()}, db, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ReadDeploymentResponse{Result: res}
	if custom, ok := interface{}(in).(DeploymentsDeploymentWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// DeploymentsDeploymentWithBeforeRead called before DefaultReadDeployment in the default Read handler
type DeploymentsDeploymentWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// DeploymentsDeploymentWithAfterRead called before DefaultReadDeployment in the default Read handler
type DeploymentsDeploymentWithAfterRead interface {
	AfterRead(context.Context, *ReadDeploymentResponse, *gorm1.DB) error
}

// Update ...
func (m *DeploymentsDefaultServer) Update(ctx context.Context, in *UpdateDeploymentRequest) (*UpdateDeploymentResponse, error) {
	var err error
	var res *Deployment
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(DeploymentsDeploymentWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	if in.GetFields() == nil {
		res, err = DefaultStrictUpdateDeployment(ctx, in.GetPayload(), db)
	} else {
		res, err = DefaultPatchDeployment(ctx, in.GetPayload(), in.GetFields(), db)
	}
	if err != nil {
		return nil, err
	}
	out := &UpdateDeploymentResponse{Result: res}
	if custom, ok := interface{}(in).(DeploymentsDeploymentWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// DeploymentsDeploymentWithBeforeUpdate called before DefaultUpdateDeployment in the default Update handler
type DeploymentsDeploymentWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// DeploymentsDeploymentWithAfterUpdate called before DefaultUpdateDeployment in the default Update handler
type DeploymentsDeploymentWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateDeploymentResponse, *gorm1.DB) error
}

// Delete ...
func (m *DeploymentsDefaultServer) Delete(ctx context.Context, in *DeleteDeploymentRequest) (*DeleteDeploymentResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(DeploymentsDeploymentWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteDeployment(ctx, &Deployment{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteDeploymentResponse{}
	if custom, ok := interface{}(in).(DeploymentsDeploymentWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// DeploymentsDeploymentWithBeforeDelete called before DefaultDeleteDeployment in the default Delete handler
type DeploymentsDeploymentWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// DeploymentsDeploymentWithAfterDelete called before DefaultDeleteDeployment in the default Delete handler
type DeploymentsDeploymentWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteDeploymentResponse, *gorm1.DB) error
}

// List ...
func (m *DeploymentsDefaultServer) List(ctx context.Context, in *ListDeploymentRequest) (*ListDeploymentsResponse, error) {
	txn, ok := gorm2.FromContext(ctx)
	if !ok {
		return nil, errors1.NoTransactionError
	}
	db := txn.Begin()
	if db.Error != nil {
		return nil, db.Error
	}
	if custom, ok := interface{}(in).(DeploymentsDeploymentWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	pagedRequest := false
	if in.GetPaging().GetLimit() >= 1 {
		in.Paging.Limit++
		pagedRequest = true
	}
	res, err := DefaultListDeployment(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	var resPaging *query1.PageInfo
	if pagedRequest {
		var offset int32
		var size int32 = int32(len(res))
		if size == in.GetPaging().GetLimit() {
			size--
			res = res[:size]
			offset = in.GetPaging().GetOffset() + size
		}
		resPaging = &query1.PageInfo{Offset: offset}
	}
	out := &ListDeploymentsResponse{Results: res, Page: resPaging}
	if custom, ok := interface{}(in).(DeploymentsDeploymentWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// DeploymentsDeploymentWithBeforeList called before DefaultListDeployment in the default List handler
type DeploymentsDeploymentWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// DeploymentsDeploymentWithAfterList called before DefaultListDeployment in the default List handler
type DeploymentsDeploymentWithAfterList interface {
	AfterList(context.Context, *ListDeploymentsResponse, *gorm1.DB) error
}
